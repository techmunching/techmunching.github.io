<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="ie=edge"> <title>Privacy Policy | TechMunching</title> <meta name="generator" content="Jekyll v4.2.0"/> <meta property="og:title" content="Privacy Policy"/> <meta property="og:locale" content="en_US"/> <meta name="description" content="TechMunching privacy policy is simple"/> <meta property="og:description" content="TechMunching privacy policy is simple"/> <link rel="canonical" href="https://techmunching.com/privacy-policy.html"/> <meta property="og:url" content="https://techmunching.com/privacy-policy.html"/> <meta property="og:site_name" content="TechMunching"/> <meta name="twitter:card" content="summary"/> <meta property="twitter:title" content="Privacy Policy"/> <script type="application/ld+json">
{"description":"TechMunching privacy policy is simple","headline":"Privacy Policy","@type":"WebPage","url":"https://techmunching.com/privacy-policy.html","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://techmunching.com/assets/images/logo.png"}},"@context":"https://schema.org"}</script> <link rel="shortcut icon" type="image/x-icon" href="/assets/images/logo.png"> <link rel="preconnect" href="https://glyph.medium.com"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"> <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/prism.css"> <link rel="stylesheet" href="/assets/css/theme.css"> <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script> <script async src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/js/all.min.js" integrity="sha256-IKPvaXm75eTeGvrsxwPh00y8Xjzqs203hTlQYydpLXI=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y7HGWZX785"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-Y7HGWZX785");</script> </head> <body class=""> <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top"> <div class="container"> <div class="d-flex flex-row"> <div class="p-1" style="min-width: 40px;width: 10%;"> <a href="/"><img src="/assets/images/logo_small.webp" alt="TechMunching Home"/></a> </div> <div class="p-1"> <a class="navbar-brand" href="/"><strong>TechMunching</strong> </a> </div> <div class="p-1"> <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> </div> </div> <div class="navbar-collapse collapse" id="navbarColor02"> <ul class="navbar-nav mr-auto d-flex align-items-center"> <li class="nav-item"> <a style="color: red;font-size: 1.5em;" target="_blank" class="nav-link" href="https://TechMunching.com/"><i class="fab fa-youtube"></i></a> </li> <li class="nav-item"> <a style="color: #15aabf;font-size: 1.5em;padding-top: 7%;" class="nav-link" href="https://TechMunching.com/"><i class="fas fa-mug-hot"></i></a> </li> </ul> <ul class="navbar-nav ml-auto d-flex align-items-center" style="min-width: 20%;"> <script src="/assets/js/lunr.js"></script> <script>function lunr_search(e){if($("#lunrsearchresults").show(100),$("body").addClass("modal-open"),document.getElementById("lunrsearchresults").innerHTML='<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div id="modalSearchContent" class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>',e){document.getElementById("modtit").innerHTML="<h5 class='modal-title'>Search results for '"+e+"'</h5>"+document.getElementById("modtit").innerHTML;var t=idx.search(e);if(0<t.length)for(var a=0;a<t.length;a++){var o=t[a].ref,s=documents[o].url,n=documents[o].title,i=documents[o].body.substring(0,160)+"...";document.querySelectorAll("#lunrsearchresults ul")[0].innerHTML=document.querySelectorAll("#lunrsearchresults ul")[0].innerHTML+"<li class='lunrsearchresult'><a href='"+s+"'><span class='title'>"+n+"</span><br /><small><span class='body'>"+i+"</span><br /><span class='url'>"+s+"</span></small></a></li>"}else document.querySelectorAll("#lunrsearchresults ul")[0].innerHTML="<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>"}return $("#resultsmodal").click(function(e){document.getElementById("modalSearchContent").contains(e.target)||$("#btnx").click()}),!1}$(function(){$("#lunrsearchresults").on("click","#btnx",function(){$("#lunrsearchresults").hide(50),$("body").removeClass("modal-open"),$("#resultsmodal").off("click")})});var documents=[{id:0,url:"https://techmunching.com/404/",title:"",body:" 404 Page not found :(  The requested page could not be found. "},{id:1,url:"https://techmunching.com/about.html",title:"About",body:"Made with by TechMunching @wowthemesnet. "},{id:2,url:"https://techmunching.com/author-tech-munching.html",title:"TechMunching Admin",body:"                        {{page. title}} Follow:         {{ site. authors. admin. site }}         {{ site. authors. admin. bio }}                                   Posts by {{page. title}}:       {% assign posts = site. posts | where: author , TechMunching Admin  %}      {% for post in posts %}      {% include main-loop-card. html %}      {% endfor %}  "},{id:3,url:"https://techmunching.com/authors-list.html",title:"Authors",body:"{{page. title}}:     {% for author in site. authors %}                                         {{ author[1]. name }} :       (View Posts)      {{ author[1]. bio }}                          &nbsp;       &nbsp;                                    {% endfor %}  "},{id:4,url:"https://techmunching.com/buy-me-a-coffee.html",title:"Buy me a coffee",body:"Hi! We are team TechMunching, web designer &amp; developer at WowThemes. net. The free items I create are my side projects and Mundana for Jekyll is one of them. You can find all the work I release for free here. You have my permission to use the free items I develop in your personal, commercial or client projects. If you\u2019d like to reward my work, I would be honored and I could dedicate more time maintaining the free projects. Thank you so much! Buy me a coffee "},{id:5,url:"https://techmunching.com/categories.html",title:"Categories",body:"          Categories          {% for category in site. categories %}     {{ category[0] }}:           {% assign pages_list = category[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "},{id:6,url:"https://techmunching.com/contact.html",title:"Contact",body:"  Please send your message to {{site. name}}. We will reply as soon as possible!   "},{id:7,url:"https://techmunching.com/",title:"",body:"  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          {% if latest_post. image %}  &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;     {% endif %}  {% if latest_post. video %}            &lt;source src= {% if latest_post. video contains  ://  %}{{ latest_post. video }}{% else %} {{site. baseurl}}/{{ latest_post. video}}{% endif %}  type= video/mp4 &gt;      Your browser does not support the video tag.            {% endif %}        {{ latest_post. title }}  &lt;/h2&gt;      {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}        &lt;/div&gt;  &lt;/div&gt;  &lt;/div&gt;                {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                          &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{site. baseurl}}/{{ second_post. image }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}         {% if second_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if second_post. video contains  ://  %}{{ second_post. video }}{% else %}{{site. baseurl}}/{{ second_post. video }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                          {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                 {% if third_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if third_post. video contains  ://  %}{{ third_post. video }}{% else %}{{site. baseurl}}/{{ third_post. video }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                              {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                 {% if fourth_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if fourth_post. video contains  ://  %}{{ fourth_post. video }}{% else %}{{site. baseurl}}/{{ fourth_post. video }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                          {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                &lt;/div&gt;  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More            \t             {% endif %}{% endfor %}  {% endif %}                All Stories:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      &lt;/div&gt;"},{id:8,url:"https://techmunching.com/privacy-policy.html",title:"Privacy Policy",body:"\u201d{{site. name}}\u201d takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor\u2019s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google\u2019s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "},{id:9,url:"https://techmunching.com/tags.html",title:"Tags",body:"          Tags          {% for tag in site. tags %}     {{ tag[0] }}:           {% assign pages_list = tag[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "},{id:10,url:"https://techmunching.com/page2/",title:"",body:"  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          {% if latest_post. image %}  &lt;div class= topfirstimage  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;     {% endif %}  {% if latest_post. video %}            &lt;source src= {% if latest_post. video contains  ://  %}{{ latest_post. video }}{% else %} {{site. baseurl}}/{{ latest_post. video}}{% endif %}  type= video/mp4 &gt;      Your browser does not support the video tag.            {% endif %}        {{ latest_post. title }}  &lt;/h2&gt;      {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}        &lt;/div&gt;  &lt;/div&gt;  &lt;/div&gt;                {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                          &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{site. baseurl}}/{{ second_post. image }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}         {% if second_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if second_post. video contains  ://  %}{{ second_post. video }}{% else %}{{site. baseurl}}/{{ second_post. video }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                          {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                 {% if third_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if third_post. video contains  ://  %}{{ third_post. video }}{% else %}{{site. baseurl}}/{{ third_post. video }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                              {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                 {% if fourth_post. video %}                         &lt;video type= video/mp4  style= max-width:100%  autoplay muted loop class= w-100  src= {% if fourth_post. video contains  ://  %}{{ fourth_post. video }}{% else %}{{site. baseurl}}/{{ fourth_post. video }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                          {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                &lt;/div&gt;  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More            \t             {% endif %}{% endfor %}  {% endif %}                All Stories:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      &lt;/div&gt;"},{id:11,url:"https://techmunching.com/No-more-dealing-with-slow-MacBookPro/",title:"No more dealing with slow MacBookPro",body:"2021/01/28 - Here\u2019s another MacBookPro 101 for you!!      Your browser does not support the video tag.   Has it ever happened with you that you are all set to rock the virtual meeting with your presentation and just before sharing your MacBook\u2019s screen, it froze? Not your heart but the Laptop, the trackpad isn\u2019t anymore in control of the cursor, the fan is on full throttle, yet everything is all slowed down. It\u2019s not a hidden fact now that Apple throttles the CPU when your MacBook heats up. While this would have been a bearable scenario if heating up wasn\u2019t necessarily an often scenario, but enough applications are running on our system to beat the shit out of it. This is even more common for my fellow developer friends. Well, a good way out people might suggest to this would be to buy an M1 Chip MacBook Pro, if you can afford that it might be best to stop reading this blog further and visit a nearby apple store. However, if you have recently bought a MacBook Pro wouldn\u2019t necessarily want to do that, please keep reading. I suggest using the Macs Fan Control (http://crystalidea. com/macs-fan-control) application on your MacBook. This helps you control the fan speed without tying it with the current temperature.  Install the application.  Right-click on MacsFanControl in TaskBar Select Full BlastHere is what I suggest - Turn on the fan to full throttle and let your fan always work at full speed. This hack has allowed me to stay at peace and not worry about being slowed down in the best of moments. Here is the snapshot of the settings your need to opt for:  I hope it helps my fellow mates. ! Please consider commenting on the post below what else would you like to read on our blog. We make weekly blogs about tech and more. "},{id:12,url:"https://techmunching.com/Largest-sub-matrix-rectangle-with-rearrangement-with-all-1s/",title:"Largest sub matrix rectangle with rearrangement with all 1s",body:"2021/01/17 - We at Tech Munching provide you the cleanest, easy to understand solutions to difficult competitive coding questions. This question #1727 appeared in LeetCode contest #224.  Here is the question: You are given a binary matrix\xa0matrix\xa0of size\xa0m x n, and you are allowed to rearrange the\xa0columns\xa0of the\xa0matrix\xa0in any order. Return\xa0the area of the largest submatrix within\xa0matrix\xa0where\xa0every\xa0element of the submatrix is\xa01\xa0after reordering the columns optimally. Example 1: Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]Output: 4Explanation: You can rearrange the columns as shown above. The largest submatrix of 1s, in bold, has an area of 4. Here is our proposed solution:  Not to console the audience reading it after the contest, however, this wasn\u2019t necessarily a medium problem. As with life, this problem also has multiple solutions to it. So, please comment down in case you would need further solutions based on DP or so. Let\u2019s try to look at the problem in a different way, can we think of value 1 as adding a floor to the building and value 0 as ground level of the building. Our task is to find the max rectangle with parallel buildings and because the columns can be rearranged, we can move the buildings. Here are the height of the building for each row:       \xa0   Col 1   Col 2   Col 3   \xa0         Row 1   0   0   1   \xa0       Row 2   1   1   2   (Previous floor adds up in coloumn 3)       Row 3   2   0   3   (Ground floor in coloumn 2 nullifies previous height)    Since, we can actually move the coloumns, above rows after sorting can be represented as:       \xa0   Col 1   Col 2   Col 3         Row 1   1   0   0       Row 2   2   1   1       Row 3   3   2   0    Once you reach this state, finding the max rectangles for each building is height * width. For example: Row 3 &amp; Col 1 : 3 (height) * 1 (width) Row 3 &amp; Col 1 &amp; Col 2 : 2 (height) * 2 (width) Here is complete solution: class Solution {public:  int largestSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {    if (matrix. empty()) return 0;        vector&lt;int&gt; brickLevel (matrix[0]. size(), 0);        int answer = numeric_limits&lt;int&gt;::min();        for (auto i = 0; i &lt; matrix. size(); i++) {      for (auto j = 0; j &lt; matrix[0]. size(); j++) // set the brick value        brickLevel[j] = matrix[i][j] == 0 ? 0 : brickLevel[j] + 1;            // sort bricks to keep buildings consecutive      auto mx = brickLevel;      sort(mx. begin(), mx. end(), greater());            for (auto i = 0; i &lt; mx. size(); i++)        answer = max(answer, (i + 1) * mx[i]);    }    return answer;  }};The time complexity for a matrix of MxN will be MNlog(N). That\u2019s easy to understand, the outer loop iterates M rows which iterates N columns and sort vector of length N which is M * (N + Nlog(N)), which asymptotically is MNlog(N). Please feel free to comment down below in case you find any flaw or would need deeper understanding in any aspects. "},{id:13,url:"https://techmunching.com/lambdas-and-closures-in-c/",title:"Lambdas and closures in C++",body:"2020/10/27 - What are closures vs how lambdas are different from closures?   Your browser does not support the video tag. They look similar!! Table of Contents:  Just your everyday functions Lambda Expressions What are closures Lambdas vs. Closures Distinction by Examples Close analog to a closureJust your everyday functions: When most people think of functions, they think of named functions such as - std::string a_named_function () {   return  This string is returned from a named function ; }// A named functionThese are called by name, of course: foo(); //returns the string aboveLambda Expressions: The term \u201clambda\u201d is short for lambda expression, and a lambda is just that \ud83d\ude0a:    Lamdba expression \u2014 An *expression *that specifies an anonymous function object.     Lamdba function \u2014 This term is used interchangeably with the term \u201clambda expression. \u201d  As such, it exists only in a program\u2019s source code.  A lambda does not exist at runtime. A lambda expression specifies an object, not just a function without a name, capable of capturing variables in scope.  Lambdas can frequently be passed around as objects.  A lambda is essentially a function object that is specified inline.  In addition to its own function parameters, a lambda expression can refer to local variables in the scope of its definition. What are closures: * What is C++ specific part here A closure is a general concept in programming that originated from functional programming. When we talk about the closures in C++, they always come with lambda expressions. In any other language like Python, closure are unrelated to Lambdas \ud83d\ude0a A closure is any function that closes over the environment in which it was defined. This means that it can access variables not in its parameter list. What is a Closure anyway in C++?: A value* defined (rather encapsulated) by lambda expression that consists of both the code as well as the values of the variables referred to in the code. (We will discuss this asterisk * further in this article) So closure is an anonymous function object that is created automatically by the compiler as the result of a lambda expression. A closure stores those variables from the scope of the definition of the lambda expression that is used in the lambda expression.  The runtime effect of a lambda expression is the generation of an object. Such objects are known as closures. A closure is a function that encloses its surrounding state by referencing fields external to its body. The enclosed state remains across invocations of the closure Lambdas vs. Closures: Scott Meyers puts it beautifully \u2014 \u201cThe distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class\u201d.  Closures are to lambdas as objects are to classes. As we know, a class exists only in source code; it doesn\u2019t exist at runtime. What exists at runtime are objects of the class type. Similarily -  Each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type\u2013a closure\u2013to be created (at runtime).  Lambdas occupy no data memory at runtime, for example, though they may occupy code memory.  Closures occupy data memory, but not code memory. Distinction by Examples: Let\u2019s take an example \u2014 auto f = [&amp;](int x, int y) { return fudgeFactor * (x + y); };// the expression to the right of the  =  is the lambda expression (i. e. ,  the lambda ), // The runtime object created by that expression is the closure. f itself is not a closure, it is a copy of the closure \ud83e\udd74 Ok, what do you mean?: The process of copying the closure into f may be optimized into a move but that doesn\u2019t change the fact that f itself is not the closure. The actual closure object is a temporary that\u2019s typically destroyed at the end of the statement unless you bind it to a forwarding reference(a. ka. Universal reference) or lvalue-reference-to-const. //===============================================================//auto&amp;&amp; rrefToClosure = [&amp;](int x, int y) { return fudgeFactor * (x + y); };const auto&amp; lrefToConstToClosure = [&amp;](int x, int y) { return fudgeFactor * (x + y); };//===============================================================//Let\u2019s take another example \u2014 //===============================================================//std::function&lt;void(void)&gt; closureWrapper1(){  int x = 10;  return [&amp;x](){ std::cout &lt;&lt;  Value in the closure:   &lt;&lt; x++ &lt;&lt; std::endl; };}int main(){  int x = 10;  auto func0 = [&amp;x](){x += 1; std::cout &lt;&lt;  Value in the closure:   &lt;&lt; x &lt;&lt; std::endl;};    func0(); // Prints 11    std::function&lt;void(void)&gt; func1 = closureWrapper1();   func1(); // Prints garbage value + 1 =~ garbage value}//===============================================================//func1 is not closure Instead, it\u2019s a std::function wrapper object that wrapped a closure. func0 is a copy of a closure created by the lambda expression written after it. Close analog to a closure: Function Object (Functor) \u2014 Function object overload the operator(). It could capture the values by making a copy of the variables to its member variables. The shortcoming is that for each different function call, regardless of how simple it is, we would have to implement a new class, whereas implementing a lambda expression is faster. References:  http://scottmeyers. blogspot. com/2013/05/lambdas-vs-closures. html https://leimao. github. io/blog/CPP-Closure/ https://stackoverflow. com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambdaThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day! "},{id:14,url:"https://techmunching.com/using-modern-c-class-members-and-initializations-the-right-way/",title:"Using Modern C++ class members and initializations the right way",
body:"2020/07/03 - Using In-member initialization, using constructors smartly and using class members functions in a safe and proper way to avoid mistakes Clean code!### Table of Contents  Use member initializers in the same order as their declaration Prefer in-class member initializer over constant initializations OR over default constructor.  Don\u2019t cast away const, ever! Use delegating constructors to represent common actions for all constructors of a class.   1. Use member initializers in the same order as their declaration:  Member variables are always initialized in the order they are declared in the class definition. The order in which you write them in the constructor initialization list is ignored \ud83e\udd74 Make sure the constructor code doesn\u2019t confusingly specify different orders. For e. g. this case as below \u2014 Would lead to issuesemail is declared before first_name and last_name in the class definition, hence as per the constructor call, it will be initialized first and will attempt to use the other not-yet-initialized fields which are first_name and last_name . How to make it right: This code harbors a bug that\u2019s as subtly harmful as it is hard to spot hence  Write member initializers in the same order as their declarationMany compilers (but not all) will issue a warning if you break this rule. Modern compilers Clang, MSVC detect it with the right use of right warning flags. Reason: The reason for this language design decision is to ensure there is a unique order to destroy members; otherwise, the destructor would have to destroy objects in different orders, depending on the constructor that built the object. Benefit:  Protects you from an oddity of the language without requiring everyone to know it.  Might encourage you to rethink your class design so this dependency goes away  2. Prefer in-class member initializer over constant initializations OR over default constructor:  You should don\u2019t define a default constructor that only initializes data members; use in-class member initializers instead which works as a good fallback in case you forget to initialize something. Example \u2014 A bad class that misses one initialization in a constructor Cons of not using in-member class initializerswhere the following is an example of a much better class Using in-member class initializers, Nice!!#### Reason Using in-class member initializers lets the compiler generate the function for you. Also, the compiler-generated function can be more efficient \ud83d\ude0a Benefits:  No overhead of taking care of initializing constants separately in each constructor.  Performance gain by using standard default constructors.   3. Don\u2019t cast away const, ever!:  We shouldn\u2019t cast away from getter functions even when there seems a need. For e. g. \u2014 Stuff is a class that does some calculations overnumber1 and number2 and computes the result. Now getValue() const is a function that fetches the value, and being a getter function is marked const. number1 and number2 are updated byService1() and Service2() functions respectively. Now, in case read frequency of getValue() is much more than the number of writes, we should preemptively update the cachedValue which is returned. Such as \u2014 However, in case the number of writes is much more, we should follow a lazy calculation approach where we set a dirty flag such as below \u2014 getValue function would show error as it\u2019s marked constBut this poses a problem because const function can not modify this **newly introduced class member variable **cachedValid .  A wrong fix **would be to remove const from **getValue() function *Another wrong fix **would be to const_cast over \u201cthis\u201d* pointer.   Reason:  Doing this makes a lie out of const. Any variable is actually declared asconst, modifying it may result in undefined behavior.  Allows getValue() function to change anything in the instance.  The header file is now speaking a lie basically.   Correct Fix:  The right fix would be to declare cachedValid and cachedValue as mutable so that thegetValue() function can only modify the mutable ones. The correct fix#### Benefits of correct fix  Header file tells the truth getValue() function can only change the mutable variables Code accessing mutable members is shorter and more readable Easier to write, read, and maintain Const-correctness may enable optimizations \ud83d\ude0a  4. Use delegating constructors to represent common actions for all constructors of a class:  The common action gets tedious to write and may accidentally not be common. Hence, wherever possible we should refer to existing constructors. For e. g. \u2014 This Date is a bad class. A bad series of constructors, duplicate logicGood!! Using delegating constructors#### Reason To avoid repetition and accidental differences. References:  https://www. youtube. com/watch?v=XkDEzfpdcSg C++ Coding Standards: 101 Rules, Guidelines, and Best Practices by Herb Sutter, Andrei Alexandrescu https://isocpp. github. io/CppCoreGuidelines/CppCoreGuidelinesThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day!"},{id:15,url:"https://techmunching.com/object-construction-order-in-case-of-virtual-and-or-multiple-inheritance/",title:"Object construction order in case of virtual and/or multiple inheritance",body:"2020/07/03 - How virtual vs. multiple inheritance affect class object construction order?   Your browser does not support the video tag. I\u2019ll try to keep this post short and simple \ud83d\ude0a Table of Contents:  An example class having virtual and/or multiple inheritance What are the rules for object construction order? Understanding the object construction order rules Let\u2019s apply the rules, shall we? Bonus QuestionExample: A class having virtual and/or multiple inheritance: class X is declared here as inherited by D1, D2 which in turn are inherited by other class in a complex manner by other classes. This will be our complex example Here as we clearly see following can be established \u2014 1) V1 inherited by B12) D1 inherited by V13) V2 inherited by B1 and B24) D2 inherited by B3 and V25) X inherited by D1 and D2 What are the rules for object construction order?: The following set of rules is applied recursively:- 1. First comes virtual: First, the most derived class\u2019s constructor calls the constructors of the virtual base class subobjects. The very first constructors to be executed are the virtual base classes anywhere in the hierarchy. Virtual base classes are initialized In depth-first, left-to-right order. 2. Then comes multiple inheritance \u2014: After all virtual base class constructors are finished, the construction order is generally from base class to derived class. Direct base class subobjects are constructed in the order they are declared in the class definition. 3. Next comes class members: Next, (nonstatic) member subobjects are constructed, in the order, they were declared in the class definition. 4. Finally the constructor body: In the last, the body of the constructor is executed. Also, one point to be noted is that \u2014  Whether the inheritance is public, protected, or private doesn\u2019t affect initialization order Understanding the object construction order rules: The rules are easiest to understand if you imagine that the very first thing the compiler does in the derived class\u2019s constructor is to make a hidden call to the constructors of its virtual base and then non-virtual base classes (hint: that\u2019s the way many compilers actually do it).  It\u2019s like a DFS where the order on a same level is driven by class definitionExample \u2014 class D inherits from both ** B1 ** and ** B2 **,  The constructor for **B1 ** executes first then the constructor for B2, Then the constructor for D. This rule is applied recursivelyFor example, if B1 ** inherits from **B1a and B1b, and B2 inherits from B2a and B2b,then the final order is  B1a =&gt; B1b =&gt; **B1 **, and then B2a =&gt; B2b =&gt; B2* and ofcourse in the end D. Note that the order B1 ** and then **B2 (or B1a then B1b) is determined by the order that the base classes appear in the declaration of the class, not in the order that the initializer appears in the derived class\u2019s initialization list. [ Refer https://medium. com/pranayaggarwal25/using-modern-class-members-and-initializations-c11e931c3ba for more details about class member initializations ] Let\u2019s apply the rules, shall we?: Looks easier now, doesn\u2019t it? The initialization order for a X object in Example 2 is as follows, where each constructor call shown represents the execution of the body of that constructor: So \u2014 First \u2014 Construct the virtual bases V1 and V2 recursively by rulesAfter that, construct the remaining nonvirtual bases: Second \u2014 Construct the remaining non-virtual bases D1 and D2Next, construct the members M1 ** and **M2 \u2014 Third \u2014 Class member constructionand in the last \u2014 Final construction if you\u2019re a fan of graphics, here is how the inheritance hierarchy looks like : Inheritance and object construction hierarchy (v means Virtual) That\u2019s pretty much it! Bonus Question Time, yay!! \ud83d\ude09: Thanks for reading it till here. What is the exact order of destructors in a multiple and/or virtual inheritance situation?: The exact opposite of the same constructor order. Reminder to make your base class\u2019s destructor virtual, at least in the normal case. Why, I think you already know why? \ud83d\ude0a When someone says delete using a Base pointer that\u2019s pointing at a Derived object, had Base\u2019s destructor not been virtual, Derived\u2019s destructor would not have been called \u2013 with likely bad effects, such as resources owned by Derived not being freed. References:  http://www. gotw. ca/gotw/080. htm https://isocpp. org/wiki/faq/multiple-inheritance#mi-vi-ctor-orderThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day!"},{id:16,url:"https://techmunching.com/passing-smart-pointers-shared-ptr-and-unique-ptr/",title:"Passing smart pointers shared_ptr and unique_ptr",body:"2020/06/17 - General guidelines to follow for passing shared_ptr and unique_ptr as function arguments and at the time of return.   As always, prefer unique_ptr to shared_ptr, unless you intend to share ownership. Introduction:  Always ask yourself \u201cDo I really need to pass a smart pointer ?\u201d std::unique_ptr usage std::shared_ptr usage How to pass correctly pass raw pointer/reference? For Returning smart pointers, what is the norm?Always ask yourself \u201cDo I really need to pass a smart pointer ?\u201d: You should always assess if passing smart pointers as a function parameter is what you really need. In most cases, you just need to use it and be done with it. In those cases, it\u2019s always good to get a raw pointer and pass it on. Now before we go further, I must tell you that raw pointers aren\u2019t always bad. They can be quite useful in many cases as we\u2019ll read in this post. Guideline:  Don\u2019t pass a smart pointer as a function parameter unless you want to use or manipulate it, such as to share or transfer ownership. Prefer passing objects by non-owning raw pointers (*) OR references (&amp;). Reason and Example: void f( widget* );  void f( widget&amp; ); They stay agnostic of whatever lifetime policy the caller use and are good to observe an object whose lifetime we know exceeds that of the pointer or reference. This is restrictive and can\u2019t beeasy to commit always then we\u2019ll see and asset the best possible way to pass smart pointers. Step1: Know your lifetimes\u2026The full picture would keep becoming more clear :) So following should be the guideline if we are sure about the lifetime \u2014 Guideline to follow in case of no share or transfer of ownership and valid lifetime std::unique_ptr usage: By value unique_ptr&lt; type &gt; assumes ownership of a widget Reason: This is the preferred way to express a consuming function, also known as a \u201csink\u201d. Using unique_ptr in this way in both documents and code, enforces well the function call\u2019s ownership transfer (Expresses a \u201csink\u201d function) Such as \u2014 void sink(unique_ptr&lt;widget&gt;); // takes ownership of the widget// whereasvoid uses(widget*); // just uses the pointed objectAnd a bad example is below \u2014 void thinko(const unique_ptr&lt;widget&gt;&amp;); // usually not what you want!unique_ptr passing guidelines and our guideline picture is now \u2014 Step2: Know your transfers \u2026 More clear picture :) Guideline::  Express a \u201csink\u201d function using a by-value unique_ptr parameter. Use a non-const unique_ptr&amp; parameter only to modify the unique_ptr. std::shared_ptr usage: Passing shared_ptr by value only when you are sharing the ownership: void f( shared_ptr&lt;widget&gt; ); // only when you want to retain  // object and share ownership Sharing ownership comes with a cost, so make sure you really mean and intend to pay that price. In pass by value, the argument is copied (usually unless temporary) on entry to the function, and then destroy it (always) on function exit. Passing shared_ptr by value means \u2014 1) A new shared_ptr will be copy constructed. 2) Ref count which is an atomic shared variable gets increased. 3) shared_ptr copy gets destroyed at the end of the function. 4) Ref count which is an atomic shared variable gets decreased. [ Related post: https://medium. com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc ] void f( const shared_ptr&amp;&lt;widget&gt; ); // may share ownership void f( shared_ptr&amp;&lt;widget&gt; ); // may reset pointerIn the special case where the function *might* share ownership but doesn\u2019t necessarily take a copy of its parameter on a given call, then pass a const-ref to avoid the copy on the calls that don\u2019t need it. So for shared_ptr follow this \u2014 shared_ptr passing guidelines And finally, we have our full guideline picture here \u2014 Step3: The final guideline picture How to pass correctly pass raw pointer/reference?: As we have seen above that functions should prefer to pass raw pointers and references down call chains wherever possible. At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive. You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below. To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree. Consider this code, the following should not pass code review: // global (static or heap), or aliased local . . .  shared_ptr&lt;widget&gt; g_p = . . . ;void my_code() {  // BAD: passing pointer or reference obtained from a non-local  // smart pointer that could be inadvertently reset somewhere  // inside f or its callees  f(*g_p); // BAD: same reason, just passing it as a  this  pointer  g_p-&gt;func(); }The fix is simple \u2014 take a local copy of the pointer to keep a ref count for your call tree: // global (static or heap), or aliased local . . .  shared_ptr&lt;widget&gt; g_p = . . . ;void my_code() {  // **cheap:** 1 increment covers this entire function and call trees  auto pin = g_p; // **GOOD:** passing pointer or reference obtained from a local  // unaliased smart pointer  f(*pin); // **GOOD:** same reason  pin-&gt;func(); }For Returning smart pointers, what is the norm?: You should follow the same logic above:  Return smart pointers if the caller wants to manipulate the smart pointer itself, return raw pointers/references if the caller just needs a handle to the underlying object. If you really need to return smart pointers from a function, take it easy and always return by value. That is: std::unique_ptr&lt;Object&gt; getUnique(); std::shared_ptr&lt;Object&gt; getShared(); std::weak_ptr&lt;Object&gt; getWeak();There are at least three good reasons for this:  Move Semantics \u2014 Smart pointers are powered by move semantics: the dynamically-allocated resource they hold is moved around, not wastefully copied.  Return Value Optimization (RVO) \u2014All modern compilers are able to detect that you are returning an object by value, and they apply a sort of return shortcut to avoid useless copies. Starting from C++17, this is guaranteed by the standard. Returning by reference inhibits that shortcut.  Object deletion probability \u2014 Returning std::shared_ptr by reference doesn\u2019t properly increment the reference count, which opens up the risk of deleting something at the wrong time, by incurring the risk of having the object deleted (that may be local) when it goes out of scope in another context. Thanks to RVO. you don\u2019t need to move anything when returning a std::unique_ptr also. std::unique_ptr&lt;Object&gt; getUnique() {  std::unique_ptr&lt;Object&gt; p = std::make_unique&lt;Object&gt;();  return p;  // also return std::make_unique&lt;Object&gt;(); }References:  https://herbsutter. com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ http://isocpp. github. io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam https://www. internalpointers. com/post/move-smart-pointers-and-out-functions-modern-cThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day!"},{id:17,url:"https://techmunching.com/few-modern-c-puzzles/",title:"Few Modern C++ Puzzles",body:"2020/06/15 - Some puzzles from various talks, blog posts, and other bits Table of Contents:  Puzzle 1: Capturing unique_ptr by reference Puzzle 2: Capturing the temporary by the reference Puzzle 3: Making mistakes with std functions usage Puzzle 4: Throwing away the deadPuzzle 1: Capturing unique_ptr by reference: unique_ptr&lt;A&gt; myFun(){  unique_ptr&lt;A&gt; pa(new A());  return pa;}const A&amp; rA = *myFun();This code compiles but rA contains garbage. Why is this code invalid? Note: if we assign the return of myFun to a named unique_ptr variable before dereferencing it, it works fine. Answer:: The unique_ptr will pass the ownership to another unique_ptr, but in this code, there is nothing to capture the ownership from the returning pointer. In other words, It can not transfer the ownership, so it will be destructed. The proper way is: unique_ptr&lt;A&gt; rA = myFun(); // Pass the ownershipor const A rA = *myFun(); // Store the values before destructionIn this code, the returning pointer will be destructed and the reference is referring to an object which is destructing soon after that using this reference invokes undefined behavior. Puzzle 2: Capturing the temporary by the reference: vector&lt;bool&gt; vb{true, true, false, true};auto proxy = vb[0];std::cout &lt;&lt; proxy // ok, Prints truevb. reserve(100); // A: ???std::cout &lt;&lt; proxy // Error!! likely to print false on clang, why?Answer:: Line A invalidates proxy so proxy was invalidated by vb. reserve. Take below example \u2014 void example_1_1_3() { string_view s;   // s points to null string name =  abcdefghijklmnop ; s = name;    // A: s points to {name'} i. e. data owned by name\u2019 cout &lt;&lt; s[0];  // B: ok \u2013 s[0] is ok because {a} is alive name =  frobozz ; // C: name modified =&gt; name\u2019 is invalid cout &lt;&lt; s[0];   // D: error \u2013 because it contains {invalid}}which is why guideline says \u2013  Never use the reference in case of a temporary argument. Take below example \u2014 char&amp; c = std::string{ hello my pretty long string }[0];cout &lt;&lt; c; // (X) wrong to initialize a// reference \u2018c\u2019 with an invalid pointer, pointer// was invalidated with temporary string was// destroyed. Puzzle 3: Making mistakes with std functions usage: int main() {  auto x=10, y=2; auto&amp; good = min(x,y); // ok, {x,y} cout &lt;&lt; good; // ok, fine.  auto&amp; bad = min(x,y+1)  cout &lt;&lt; bad; // ERROR, why??}Answer:: int main() {  auto x=10, y=2; auto&amp; good = min(x,y); // ok, {x,y} cout &lt;&lt; good; // ok, fine.  auto&amp; bad = min(x,y+1)  // A: IN: {x, temp(y+1)} // OUT: temp2 obtained by {x,temp} // min() returns temp2 // temp destroyed hence \u2192 temp2 = {invalid} cout &lt;&lt; bad; // ERROR, bad initialized as invalid now}In normal C++, this code compiles but has undefined behavior. Note In practice, on the three major compilers (GCC, VC++, clang) this code does not crash and appears to work. That\u2019s because one manifestation of \u201cundefined behavior\u201d can be \u201chappens to do what you expect. \u201d Nevertheless, this is undefined so one should be careful. Puzzle 4: Throwing away the dead: // godbolt. org/z/p_QjCRstatic int gi = 0;void f() { int i = 0; throw &amp;i; // ERROR, why?? throw &amp;gi; // OK}Answer:: Unlike a return, the type of a thrown object cannot be carried through function signatures. Therefore, do not throw a Pointer with a lifetime other than static. References:  https://stackoverflow. com/questions/30858850/dereferencing-a-temporary-unique-ptr http://www. open-std. org/jtc1/sc22/wg21/docs/papers/2018/p1179r0. pdf"},{id:18,url:"https://techmunching.com/coroutines-and-their-introduction-in-c/",title:"Coroutines and their introduction in C++",body:"2020/05/30 - Let\u2019s discuss what coroutines are in general and how C++20 is introducing them Table of Contents:  Prerequisite Terminology What are coroutines? Coroutines vs Subroutines? Coroutines vs Threads Applications of coroutines Example in Python How to simulate coroutines in traditional C++ Coroutines in C++20 RestrictionsPrerequisite Terminology:  Cooperative Multitasking (a. k. a non-preemptive multitasking) \u2014 If multitasking participant process or thread voluntarily let go of control periodically or when idle or logically blocked. This type of multitasking is called \u201ccooperative\u201d because all programs must cooperate for the entire scheduling scheme to work.  Subroutine \u2014 Any regular function that you write is a subroutine. What are Coroutines?: Coroutines are stackless functions designed for enabling co-operative Multitasking, by allowing execution to be suspended and resumed. Coroutines suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. This allows for sequential code that executes asynchronously (e. g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses. This is why coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, state machines, and pipes. Coroutines vs Subroutines?:  With subroutines, execution begins at the start and finished on exit.  Subroutines are special cases of coroutines. Any subroutine can be translated to a coroutine which does not call \u2018yield\u2019 (relinquish control).    Subroutines only return once and don\u2019t hold the complete state between invocations. In contrast \u2014   Coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine\u2019s point of view, it is actually not exiting but calling another coroutine.  A coroutine instance holds state and varies between invocations. Coroutines vs Threads:  Coroutines are designed to be performing as lightweight threads.  Coroutines provide concurrency but not parallelism [Important!] Switching between coroutines need not involve any system/blocking calls so no need for synchronization primitives such as mutexes, semaphores. Thus coroutines \u2014  provide asynchronicity and resource locking isn\u2019t needed.  are useful in functional programming techniques.  increase locality of reference. Applications of Coroutines:  Actor Model: They are very useful to implement the actor model of concurrency. Each actor has its own procedures, but they give up control to the central scheduler, which executes them sequentially.  Generators: It is useful to implement generators that are targeted for streams particularly input/output and for traversal of data structures.  Reverse Communication: They are useful to implement reverse communication which is commonly used in mathematical software, wherein a procedure needs the using process to make a computation. Example 1\u2014To read a file and parse it while finding (matching) some meaningful data, you can either read step by step at each line, which is fine. You may also load the entire content in memory, which won\u2019t be recommended for large text. Coroutines are there to throw away the stack concept completely. Stop thinking of one process as the caller and the other as the callee, and start thinking of them as cooperating equals. Execution flow for reading a file and finding text Example 2 \u2014You have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The pseudo-code might look like this:   var q := new queue   coroutine produce     loop      while q is not full         create some new items         add the items to q       yield to consume  coroutine consume     loop       while q is not empty         remove some items from q         use the items       yield to produceThe queue is then completely filled or emptied before yielding control to the other coroutine using the yield command. (This example is often used as an introduction to multithreading, two threads are not a must need for this). An example in Python: If you have used Python, you may know that there is a keyword called yield that allows loop back and forth between the caller and the called function until the caller is not done with function or the function terminates because of some logic it is given. # A Python program to generate numbers in a range using yielddef rangeN(a, b): i = a  while (i &lt; b):  yield i  i += 1 # Next execution resumes from this pointfor i in rangeN(1, 5): print(i)How to simulate coroutines in traditional C++: To simulate coroutines in traditional C++ is challenging as for every response to a function call, there is a stack being initialized that keeps track of all its variables and constants and gets destroyed when the function call ends. For the same range example, to simulate a simple switch coroutine suspend-resume we can do something like \u2014 // A bad simulation of coroutine, no state saving #include&lt;iostream&gt;int range(int a, int b)  {   static long long int i = a-1;  for (;i &lt; b;)   {    return ++i;   }   return 0;  }int main()  {   int i;  for (; i=range(1, 5);)    std::cout &lt;&lt; i &lt;&lt; '\n';   return 0;  }However, this doesn\u2019t hold good for coroutines criteria of saving/resuming from the saved state :( // A better simulation of coroutine, state saving!! #include&lt;iostream&gt;int range(int a, int b){ static long long int i; static int state = 0; switch (state) { case 0:  /* start of function */  state = 1;  for (i = a; i &lt; b; i++) {   return i; /* Returns control */   case 1: ; /* resume control straight after the return */  } } state = 0; return 0;}int main() { int i; for (; i = range(1, 5);)  std::cout &lt;&lt; i &lt;&lt; '\n'; return 0;}Coroutines in C++20: In c++20, coroutines are coming. A function is a coroutine if its definition does any of the following:  uses the co_await operator to suspend execution until resumed.  uses the keyword co_yield to suspend execution returning a value.  uses the keyword co_return to complete execution. Let\u2019s take a similar example to get a range. For the simplicity of this post, let\u2019s assume a generator template is something that exists already and can be used to generate a range, (This blog post from Microsoft https://docs. microsoft. com/en-us/archive/msdn-magazine/2017/october/c-from-algorithms-to-coroutines-in-c is amazing regarding the generator pattern details) #include &lt;iostream&gt;#include &lt;vector&gt; // Coroutine gets called on needgenerator &lt;int&gt; generateNumbers(int begin, int inc = 1) { for (int i = begin;; i += inc) {  co_yield i; }}int main() { std::cout &lt;&lt; std::endl; const auto numbers = generateNumbers(-10); for (int i = 1; i&lt;= 20; ++i)  std::cout &lt;&lt; numbers &lt;&lt;    ; // Runs finite = 20 times***  for (auto n:generateNumbers(0, 5)) // Runs infinite times**   std::cout &lt;&lt; n &lt;&lt;    ; // (3)  std::cout &lt;&lt;  \n\n ;}We\u2019ll cover more about coroutines later as it gets better documented and evolved. Restrictions: Every coroutine in C++ has some restrictions noted below. So coroutines \u2014  Can\u2019t return with variadic arguments Can\u2019t return using plain return Can\u2019t return placeholder (auto or Concept) Can\u2019t be constexpr functions.  Can\u2019t be constructors or destructors.  Can\u2019t be the main function. References:  https://en. cppreference. com/w/cpp/language/coroutines https://www. xenonstack. com/insights/coroutines/ https://stackoverflow. com/questions/48106252/why-threads-are-showing-better-performance-than-coroutines https://www. modernescpp. com/index. php/c-20-coroutines-the-first-overviewThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve!!Please check out our other articles and website, Have a great day!"},{id:19,url:"https://techmunching.com/using-custom-deleters-with-shared-ptr-and-unique-ptr-in-c/",title:"Using custom deleters with shared_ptr and unique_ptr in C++",
body:"2020/05/29 - How to use a custom deleter with an unique_ptr and shared_ptr Related post: https://medium. com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc Table of Contents:  Introduction The true unknown face of smart pointers What is std::default_delete indeed? Ways to specify custom deleters Using custom deleter with shared_ptr Using custom deleter with unique_ptr Storage of custom deleters Restrictions that come with custom deletersIntroduction: Why and when would we need something like that? Case 1: In order to fully delete an object sometimes, we need to do some additional action. What if performing \u201cdelete\u201d (that smart pointers do automatically)is not the only thing which needs to be done before fully destroying the owned object. Case 2: We can\u2019t bind a shared_ptr or unique_ptr to a stack-allocated object, because calling delete on it would cause undefined behaviour. Case 3: Mix of programming languages code, such as C++ with Obj-C++. As objective-c may need a complex release mechanism for its data types such as calling CFRelease, we would be in need of a custom deleter. Case 4: In C where, when you wrap FILE*, or some kind of a C style structure free(), custom deleters may be useful. and a few other cases. The true unknown face of smart pointers: std::unique_ptr: The complete type of std::unique_ptr has a second template parameter, its deleter that has a default type std::default_delete&lt;T&gt;. What is that?? No need to worry, We\u2019ll cover this together :) template&lt; class T, class Deleter = std::default_delete&lt;T&gt;&gt; class unique_ptr;// Manages a single objecttemplate &lt; class T, class Deleter&gt; class unique_ptr&lt;T[], Deleter&gt;;// Manages a dynamically-allocated array of objects std::default_delete&lt;T&gt; is a function object (a. k. a functor) that calls delete on the object when invoked. This is only the default type for invoking Deleter and it can be replaced with a custom deleter. The invocation is done using operator() on the Deleter. std::shared_ptr: You can pass any callable thing (lambda, functor) as deleter while constructing a shared pointer in the constructor as an additional argument. template&lt; class Y, class Deleter &gt;shared_ptr( Y* ptr, Deleter d );// One of the overloads of shared_ptr constructionthus specifying custom deleter with std::shared_ptr is comparatively easy. On ref count reaches zero, the shared_ptr uses the delete-expression i. e. delete ptr. Also since C++17 \u2014 // shared_ptr can be used to manage a dynamically allocated array// since C++17 by specifying template argument with T[N] or T[]. So // you may writeshared_ptr&lt;int[]&gt; myShared(new int[10]);What is std::default_delete indeed?: This is defined in &lt;memory&gt; header. template&lt; class T &gt; struct default_delete;template&lt; class T &gt; struct default_delete&lt;T[]&gt;; The non-specialized default_delete uses delete to deallocate memory for a single object.  A partial specialization for array types that uses delete[] is also provided. Members::  Constructor \u2014 can be default or templated. constexpr default_delete() noexcept = default; // defaulttemplate &lt;class U&gt;default_delete( const default_delete&lt;U&gt;&amp; d ) noexcept; // templated// Constructs a std::default_delete object from another. // Overload resolution if U* is implicitly convertible to T*.  operator() \u2014 overload for the operator() is needed for the callability of struct/class as its a function object( or functor). At the point in the code where, this operator() is called, the type must be complete and defined. Examples: Example 1:{  std::unique_ptr&lt;int&gt; ptr(new int(5));}  // unique_ptr&lt;int&gt; uses default_delete&lt;int&gt;====================================================================Example 2:{  std::unique_ptr&lt;int[]&gt; ptr(new int[10]);} // unique_ptr&lt;int[]&gt; uses default_delete&lt;int[]&gt;====================================================================Example 3:// default_delete can be used anywhere a delete functor is neededstd::vector&lt;int*&gt; v;for(int n = 0; n &lt; 100; ++n)  v. push_back(new int(n));std::for_each(v. begin(), v. end(), std::default_delete&lt;int&gt;());// Constructing the function object to be called====================================================================Example 4:{  std::shared_ptr&lt;int&gt; shared_bad(new int[10]); } // the destructor calls delete, undefined behavior as it's an array {  std::shared_ptr&lt;int&gt; shared_good(new int[10], std::default_delete&lt;int[]&gt; ());} // the destructor calls delete[], ok====================================================================Example 5: (Valid only C++17 onwards){shared_ptr&lt;int[]&gt; shared_best(new int[10]);}// the destructor calls delete[], awesome!!====================================================================Ways to specify custom deleters:  std::function \u2014 Heavy size contribution ( ~32 bytes! on x64) Function pointer \u2014 Just a pointer Stateless functor / Stateless Lambda \u2014 None.  Stateful functor / Stateful Lambda \u2014 sizeof(functor or lambda)Using custom deleter with shared_ptr: Examples \u2014 1. Use a proper functor \u2014: (Requires custom deleter for array only Prior to C++17) // declare the function objecttemplate&lt; typename T &gt;struct array_deleter{ void operator ()( T const * p) {   delete[] p;  }};// and use shared_ptr as follows by constructing function objectstd::shared_ptr&lt;int&gt; sp(new int[10], array_deleter&lt;int&gt;());2. Use a plain lambda: std::shared_ptr&lt;MyType&gt; sp(new int[10], [](int *p) { delete[] p; });3. Use default_delete (Only valid for array types before C++17): std::shared_ptr&lt;int&gt; sp(new int[10], std::default_delete&lt;int[]&gt;());Note: delete ptr is same as specifying default_delete&lt;T&gt;{}ptr. Using custom deleter with unique_ptr: With unique_ptr there is a bit more complication. The main thing is that a deleter type will be part of unique_ptr type. By default we get std::default_delete so here are some examples \u2014 For a class MyType class MyType { // . . .  // . . . };void deleter(MyType*) {// . . . }====================================================================// 1. std::function std::unique_ptr&lt;MyType, std::function&lt;void (MyType*)&gt;&gt; u1(new MyType());//OR std::unique_ptr&lt;MyType, decltype(deleter)&gt;&gt; u1(new MyType(), &amp;deleter); // 2nd argument is optional always as functor object is created by default====================================================================// 2. Function pointerstd::unique_ptr&lt;MyType, void (*)(MyType *)&gt; u2(new MyType());====================================================================// A stateless functorstruct MyTypeDeleterFunctor {   void operator()(MyType* p) {    // . . .   }};// 3. Stateless functorstd::unique_ptr&lt;MyType, MyTypeDeleterFunctor&gt;u3(new MyType());====================================================================// 4. void close_file(std::FILE* fp) { std::fclose(fp); }Storage of custom deleters: For shared_ptrWhen you use a custom deleter it won\u2019t affect the size of your shared_ptr type. If you remember, shared_ptr size should be roughly 2 x sizeof(ptr) so where does this deleter hide? As we know, shared_ptr consists of two things: pointer to the object and pointer to the control block (that contains ref count). Inside the control block structure of shared_ptr , there is a space for custom deleter and allocator. For unique_ptrunique_ptr is small and efficient; the size is one pointer so where is the custom allocator hide in this case? The deleter is part of the type of unique_ptr. And since the functor/lambda that is stateless, its type fully encodes everything there is to know about this without any size involvement. Using function pointer takes one pointer size and std::function takes even more size.  The shared_ptr always stores a deleter, this erases the type of the deleter, which might be useful in APIs. The disadvantages of using shared_ptr over unique_ptr include a higher memory cost for storing the deleter and a performance cost for maintaining the reference count. Trivia: The size of weak_ptr is the same as that of shared_ptr. Weak pointer points to the same control block as it\u2019s shared pointer. When a weak_ptr is created, destroyed, or copied a second reference count (weak pointer reference count) is manipulated. Weak count is connected with object storage deallocation (Refer prerequisite talk) Restrictions that come with custom deleter: Can\u2019t use make_shared with shared_ptr: Unfortunately, you can pass a custom deleter only in the constructor of shared_ptr there is no way to use make_shared. This might be a bit of disadvantage (Refer prerequisite talk) One can use allocate_shared and custom allocator and deleter, but that\u2019s too complex to be covered in this article. Can\u2019t use make_unique with unique_ptr: Similarly as with shared_ptr you can pass a custom deleter only in the constructor of unique_ptr and thus you cannot use make_unique. References::  https://www. reddit. com/r/cpp/comments/4gu77b/code_and_graphics_custom_deleters_for_c_smart/ https://www. bfilipek. com/2016/04/custom-deleters-for-c-smart-pointers. html https://en. cppreference. com/w/cpp/memory/default_delete https://stackoverflow. com/questions/51255583/shouldnt-stdshared-ptr-use-stddefault-delete-by-default https://www. programming-books. io/essential/cpp/using-custom-deleters-to-create-a-wrapper-to-a-c-interface-e8fe82bfeff74f699dc810b6cd5ce57aThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day! "},{id:20,url:"https://techmunching.com/universal-reference-and-perfect-forwarding/",title:"Universal Reference and Perfect forwarding",body:"2020/04/11 - Also known as Forwarding reference      Your browser does not support the video tag.  Prerequisites: Rvalue references Table of Contents::  Introduction The double life of \u201c&amp;&amp;\u201d How to identify a Universal Reference Universal Reference in templates Universal Reference in auto How does the magic of Univeral Reference work? Handle with care What is the need? The perfect forwarding problem How to work with Universal References? Universal Reference in \u201ctypedef\u201d Universal Reference in \u201cdecltype\u201d The ultimate TruthIntroduction:  Every rvalue ref is denoted by &amp;&amp; but vice versa is not true. Rvalue reference \u21d2 \u201c&amp;&amp;\u201d \u201c&amp;&amp;\u201d \u21cf Rvalue reference. \u201c&amp;&amp;\u201d in source code though may have the syntactic appearance of an rvalue reference (\u201c&amp;&amp;\u201d), but the meaning of an lvalue reference (\u201c&amp;\u201d). The double Life of \u201c&amp;&amp;\u201d: There is a double life that \u201c&amp;&amp;\u201d lives on and we need to understand that. Let\u2019s see some examples \u2014 The double life of \u201c&amp;&amp;\u201d In \u201ctype &amp;&amp;\u201d, &amp;&amp; means either - 1. Rvalue reference \u2014 As you\u2019d expect. i) Binds rvalues onlyii) Facilitates the moving of objects. 2. Forwarding reference (a. k. a Universal reference) \u2014 The mentioned type is a special type of reference that can bind anything &amp; everything. i) Universal reference can mean both Rvalue reference and Lvalue reference. ii) May facilitate copying, may facilitate moving. iii) Syntactically \u201ctype&amp;&amp;\u201d but semantically \u201ctype&amp;&amp;\u201d or \u201ctype&amp;\u201d.  Universal reference can bind lvalues, rvalues (be it const or non-const) thus everything. How to identify a Universal Reference:  If T is getting deduced and variable / parameter type is unqualified T&amp;&amp;, then only it\u2019s a Universal Reference. Here if T has already been deduced, that means no Universal Reference, plain simple rvalue reference. Not all T&amp;&amp; are Universal Reference. There are 4 possible contexts \u2014  Function template parameters \u2014template&lt;typename MyType&gt; void f(MyType&amp;&amp; param); // &amp;&amp; \u2261 rvalue reference auto declarations auto&amp;&amp; var2 = var1; typedef declarations decltype expressionsOut of the above 4, the first two are the most commonly occurring cases. As we have seen in the rule, type deduction is must so \u2014 Understanding Type Deduction Univeral references in Templates: template&lt;typename T&gt; void f(T&amp;&amp; param) {  std::cout&lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }So calling function \u2018f\u2019 in different ways will produce different results. Example 1: Calling function \u2018f\u2019 Widget w; f(w);  // T&amp;&amp; forwarding reference will be resolved as Lvalue Ref // Thus instantiating void f(Widget&amp;) out of the template void f(T&amp;&amp;) [with T = Widget&amp;]. // PrintedExample 2: adding const also \u2014 const Widget cw; f(cw);  // T&amp;&amp; forwarding reference will be resolved as Lvalue Ref to const // Thus instantiating void f(const Widget&amp;) out of the template void f(T&amp;&amp;) [with T = const Widget&amp;]. // PrintedExample 3: passing rvalues \u2014 f(Widget()); // T&amp;&amp; forwarding reference will be resolved as Rvalue Ref // Thus instantiating void f(Widget&amp;&amp;) out of the templatevoid f(T&amp;&amp;)[with T = Widget] // Printed, Why?? explained later in Table 2Example 4: adding const with rvalues const Widget cw; f(std::move(cw)); // T&amp;&amp; forwarding reference will be resolved as Rvalue Ref to const // Thus instantiating void f(const Widget&amp;&amp;) out of the templatevoid f(T&amp;&amp;)[with T = const Widget]  // Printed, Why? Explained later in Table 2Univeral references in auto: *auto&amp;&amp; var = 10; // 10 is value hence var being // a Universal reference resolves to an rvalue reference. Type of var is int &amp;&amp; std::vector&lt;int&gt; vec; auto&amp;&amp; var = vec[0]; // vector[] is int&amp; hence var being // a Universal reference resolves to an Lvalue reference. Type of var is int&amp;. int i = 10; const auto&amp;&amp; var = i; // Not a Universal Reference hence Error!!How does the magic of Univeral Reference work?: In pre-11 C++, it was not allowed to take a reference to a reference: something like A&amp; &amp; would cause a compile error. C++11, by contrast, introduces the following Reference collapsing rules: Table 1: Reference Collapsing Rules Reference collapsing is magic that enables Universal references to work. These rules are basically a logical AND of Lvalue ref implying \u20180\u2019 (zero) with Rvalue ref implying \u20181\u2019(one)  Reference Collapsing Rule#1: Lvalues are infectious. So basically in the above template examples of Univeral reference \u2014 Table 2: Reference Collapsing Rules for template Examples 1- 4 Columns with color code orange here don\u2019t have &amp;&amp; for T. The reason behind that is \u2014 \u201cIn template / auto type deduction, references become non-references before lvalue / rvalue analysis. Once deduction takes place, analysis occurs and if lvalue, reference is put back on\u201d Also, looking at the table values leads to another rule which is \u2014  Reference Collapsing Rule#2: const volatile qualifiers of original type are reserved. Remember, It\u2019s still impossible to declare a reference to reference explicitly. The compiler can do it, you can\u2019t!! Handle with care\u2026:  The thing with overloading used with universal reference is that it almost always turns out differently than expected. ========================================================= class MyWidget {  . . . template&lt;typename T&gt; // **Version 1 **  void f(const T&amp; rhs); // Best match for const Lvalue Reftemplate&lt;typename T&gt; // **Version 2 **  void f(T&amp;&amp; rhs); //** universal reference, can handle everything**   . . .  };=========================================================MyWidget m; const MyWidget cm;f(m); // Case 1, Calls Version 2!!f(std::move(m)); // Case 2, Calls Version 2 f(cm); // Case 3 Calls Version 1 f(std::move(m)); // Case 4, Calls Version 2=========================================================This happens as Version 2 of \u2018f\u2019 with Universal reference can resolve to anything if needed and thus is a better match for Lvalue Reference. However, if an exact match is found like in case 3, there Version 1 of \u2018f\u2019 is called.    Another precaution with Universal Reference is that you can\u2019t forward NULL as null pointers because that will be treated as int 0 = (zero). Another reason to use std::nullptr !!     If braced initializers are passed, the compiler can not deduce the type so you should explicitly mention the type.  What is the need? The perfect forwarding problem: Let func(E1 E2, \u2026 En); be an arbitrary function call with generic parameters E1, E2, \u2026, En. We\u2019d like to write a function wrapper such that wrapper(E1 E2, \u2026 En) is equivalent to func(E1 E2, \u2026 En). The first approach that comes to mind is \u2014 template &lt;typename T1, typename T2&gt; void wrapper(T1 e1, T2 e2) {  func(e1, e2); }But this will not work if \u2018func\u2019 accepts its param by reference since \u2018wrapper\u2019 is passing its local copies. We can add another definition. template &lt;typename T1, typename T2&gt; void wrapper(T1&amp; e1, T2&amp; e2) {  func(e1, e2); }but what if we would want to pass rvalues also? What about const-ness?As you see this will be an exponential problem. Brute force solution \u2014 These are just lvalue versions, rvalue versions will also be needed Hence there was a need for perfectly forwarding whatever parameter is received and that is achievable by Universal references. How to work with Universal References?:  A type in independent of lvalueness and rvalueness There are lvalues of type int (e. g. , variables declared to be ints), and there are rvalues of type int (e. g. , literals like 10) Widget&amp;&amp; var1 = makeWidget() // var1 is an lvalue, but // its type is rvalue reference (to Widget)As with Rvalue references, we use std::move, with Universal references we should always use std::forward&lt;T&gt; present in header which takes care of copy in case of Lvalue Ref and move in case of Rvalue Ref. std::forward keeps the reference type of x. So:  If x is an rvalue reference then std::forward is = std::move, If x is an lvalue reference then std::forward doesn\u2019t do anything. So for the previous example of wrapper function on func(E1 E2, \u2026 En) -template &lt;typename T1, typename T2&gt; void wrapper(T1&amp;&amp; e1, T2&amp;&amp; e2) {  func(std::forward&lt;T1&gt;(e1), std::forward&lt;T2&gt;(e2)); } // Awesome!! std::forward is a conditional cast but std::move is an unconditional cast. Applications of perfect forwarding are std::make_shared , std::make_unique , vector::emplace_back etc. Universal references in \u201ctypedef\u201d: template&lt;typename T&gt; class Widget { // . . .  }=========================================================Widget&lt;int&amp;&gt; w;typedef Widget&amp;&amp; UniRefToWodget; UniRefToWodget &amp;v1 = w;  // Reference collapsing, v1's type is Widget&amp;const UniRefToWodget &amp;v2 = std::move(w);  // Reference collapsing, v2's type is const Widget&amp;UniRefToWodget &amp;&amp;v3 = std::move(w);  // Reference collapsing, v3's type is Widget&amp;&amp;Universal References in \u201cdecltype\u201d: For decltype, Type deduction rule is different.  decltype(id) \u21d2 id\u2019s declared type.  decltype(non-id lvalue expression) \u21d2 Expression\u2019s type, Lvalue Ref (T&amp;) decltype(non-id rvalue expression) \u21d2 Expression\u2019s type, Non-Ref (T)decltype and Universal ReferenceUltimate Truth: \u201c&amp;&amp;\u201d is really Always Rvalue Reference, but due to the magic of Reference collapsing, It can work as a reference that can work with anything hence the fancy name \u201cUniversal Reference\u201d a. k. a. \u201cForwarding Reference\u201d. :) Bonus point : coz you made it till here!!: What does std::forward do actually? Implementation of std::forward Case 1: passing lvalues sayint&amp; , T is deduced as int&amp; Putting T as int&amp; After Reference collapsing, std::forward turns into this, which is as good as passing lvalue. The final definition looks like this after Reference collapsing Case 2: passing rvalues say int&amp;&amp; , T is deduced as int (Why? Read note mentioned after Table 2). Now After applying T as int \u2014 The final definition looks like this after Reference collapsing std::forward could do the job without std::remove_reference. Reference collapsing does the job already, so std::remove_reference&lt;T&gt; is superfluous. But it\u2019s there to turn the T&amp;t into a non-deducing context, thus forcing us to explicitly specify the template parameter when calling std::forward . References:  https://isocpp. org/blog/2012/11/universal-references-in-c11-scott-meyers#NittyGrittyDetails https://channel9. msdn. com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11 http://thbecker. net/articles/rvalue_references/section_08. html https://www. fluentcpp. com/2018/02/06/understanding-lvalues-rvalues-and-their-references/ https://eli. thegreenplace. net/2014/perfect-forwarding-and-universal-references-in-c https://www. slideshare. net/oliora/hot-universal-references-and-perfect-forwarding-82155460 http://thbecker. net/articles/rvalue_references/section_01. html"},{id:21,url:"https://techmunching.com/rvalue-references-in-c/",title:"Rvalue references in C++",body:"2020/04/07 - rvalue references Contents:  Introduction &amp; Backstory Lvalues and Rvalues Lvalue references &amp; Rvalue references What\u2019s the point of rvalues? How to get an rvalue reference from anything? Usage of rvalues and rvalue references Classic confusion of lvalue and rvalue usageIntroduction: In quest of performant code, C++11 introduced move semantics and to achieve that, a new terminology &amp; tool \u2014 rvalue references. If you find yourself always confused about lvalues, rvalues, and their references, this is the right article is for you. If you know them well, I hope you\u2019ll be kind enough to let me know your feedback and suggestions. Backstory: Prior to C++11, only one type of reference existed in C++, and so it was known as \u201creference\u201d. For better distinction, the ordinary reference X&amp; is now called an lvalue reference. lvalues and rvalues: In C++, broadly speaking every expression can be categorized as an lvalue or an rvalue \u2014 lvalue \u2014 The expression that refers to a specific memory location. So these are designated objects (that may be referred by their names) and you are allowed to take its address using \u2018&amp;\u2019 operator as all lvalues have assigned memory addresses.  ========================================================= int y = f(x) // x and y are object names and are lvalues.   ========================================================= vector&lt;int&gt; vec;  vec[0] //vec[0] is also an lvalue   ========================================================= int i = 2;  int j = ++i // Here ++i is lvalue  =========================================================When lvalues were originally defined, they were defined as \u201cvalues that are suitable to be on the left-hand side of an assignment expression\u201d. However once the const keyword was added to the C++, lvalues were split into \u2014 1) modifiable lvalues2) non-modifiable lvalues, which are const. rvalue - The expression that refers to a disposable temporary object so they can\u2019t be manipulated at the place they are created and are soon to be destroyed. An address can not be taken of rvalues.  rvalues can be realized as everything that is not an l-value  ========================================================= Myclass g(UserClass()) // Here UserClass() is an rvalue  ========================================================= int i = 1; // 1 is an rvalue  ========================================================= int j = i--; // Here i-- is an rvalue ========================================================= An rvalue has no name as its a temporary value. Lvalue references: A reference that binds to an lvalue, lvalue reference is marked with a single ampersand (&amp;). They act as an alias of the bound object. The thing about lvalue references (Table#1 and Table#2  =========================================================    int x{};  const int y = 0; // or const int x {0};  =========================================================  // l-value references (Table 1)  int &amp;ref1{ x }; // OK  int &amp;ref2{ y }; // Error  int &amp;ref3{ 5 }; // Error  =========================================================   // lvalue references to const (Table 2)  const int &amp;ref4{ x }; // OK  const int &amp;ref5{ y }; // OK but can't modify  const int &amp;ref6{ 5 }; // OK  int &amp;ref7{ 5 }; // Error  =========================================================Rvalue references: A reference that binds to an rvalue. rvalue references are marked with two ampersands (&amp;&amp;). They extend the life of the rvalue temporary objects.  Every rvalue ref is denoted by \u2018&amp;&amp;\u2019 but vice versa is not true. \u2018&amp;&amp;\u2019 may also imply forwarding (a. k. a) universal reference. Will cover Universal references in another article. The thing about rvalue references (Table#3 and Table#4)  ========================================================= int x{};  const int y = 0; // or const int x {0}; ========================================================= // r-value references (Table 3)  int &amp;&amp;ref7{ x }; // Error  int &amp;&amp;ref8{ y }; // Error  int &amp;&amp;ref9{ 5 }; // OK  ref9 = 6; // OK  ========================================================= // r-value references to const (Table 4)  const int &amp;&amp;ref10{ x }; // Error  const int &amp;&amp;ref11{ y }; // Error  const int &amp;&amp;ref12{ 5 }; // OK but can't modify  ========================================================= Lvalue references can bind to Lvalues and Rvalues. Rvalue references can only bind to Rvalues. What\u2019s the point of rvalues?: Rvalue references add the possibility to express a new intention in code: \u2014 disposable objects. When someone passes it over to you (as a reference), it means they no longer care about it. For instance, consider the rvalue reference that this function takes:  =========================================================  void f(MyClass&amp;&amp; x)  {   . . .   // Caller doesn't care about x. do whatever you want with it.   } ========================================================= Thus rvalues can be useful for \u2014    Improving performance  Taking ownership of an object How to get an rvalue reference from anything?: To move the object that the lvalue reference points to, one can move the object directly. We can cast an lvalue explicitly into an rvalue reference. This is what std::move does \u2014  std::move is used to convert to rvalue reference, it is exactly equivalent to a static_cast to an rvalue reference.  ========================================================= int x = 1, int y = 1; int &amp;&amp;ref1 = x; // Error, rvalue can't bind to lvalue int &amp;&amp;ref2 = std::move(x); // This works fine int &amp;&amp;ref3 = static_cast&lt;int&amp;&amp;&gt;(y) // Also works fine =========================================================Usage of rvalues and rvalue references: rvalue references are more often used as function parameters. This is most useful for function overloads when you want to have different behavior for lvalue and rvalue arguments. =========================================================void fun(const int &amp; lref) // lvalue arguments will select this { std::cout &lt;&lt;  l-value reference to const\n ;}void fun(int &amp;&amp; rref) //rvalue arguments will select this function { std::cout &lt;&lt;  r-value reference\n ;}int main() { int x { 5 }; fun(x); // lvalue argument calls l-value version of function  fun(5); // rvalue argument calls r-value version of function  return 0;} =========================================================Rule 1: Do not write &amp;&amp; to return type of a function, and there is no need to return a local variable using std::move. When returning a local variable, it is automatically moved in C++11 onwards. However, if the local variable is static, then it is not moved as expected. Rule 2: To use a temporary value, overload the intended function with rvalue reference and move the content. Rule 3: When you write a class with the copy constructor and the assignment operator, write also the move constructor and the move assignment operator. Feel free to refer to this article for more details. Rule 4: Always use const lvalue reference, unless you intend to change the referenced object. Rule 5: Use std::move to cast into rvalue references. Classic confusion of lvalue and rvalue usage: As we have learned above that an rvalue has no name &amp; type of the named object or anonymous object is independent of what it is. So. \u2014  A named rvalue is an lvalue as all Named objects are lvalues. Only temporary / anonymous objects are rvalues  void f(vector&lt;int&gt; &amp;&amp; x) // x is an rvalue reference {   // . . . .    // here x is an lvalue since it designates the name of an object  } There can be rvalue references that are themselves lvalues! It is common to misunderstand x as a rvalue reference when using it inside a function body like above. Here inside function bodyx itself is not an rvalue reference object because it has a name and named rvalue is an lvalue.  &amp;&amp; only implies that it is OK to dispose of x. At the place where you intend to move x, you must use std::move manually to move it, otherwise, it gets copied.  Values return by functions/methods and expression are temporary values, so you do have to use std::move to move them (C++ standard to convert to rvalue) when you pass them to functions/methods that take an rvalue reference as an argument. Take a look at the below code for example \u2014 =========================================================void fun(const int &amp;lref) // lvalue arguments will select this {  std::cout &lt;&lt;  l-value reference to const\n ; }void fun(int &amp;&amp;rref) // rvalue arguments will select this function{  std::cout &lt;&lt;  r-value reference\n ; }=========================================================int main() {  int x{ 5 };  fun(x); // lvalue argument calls lvalue version of function   int &amp;&amp;ref{ 5 };  fun(ref);// calls lvalue version of function!!! we didn't move it fun(std::move(ref));// calls r-value version of function return 0; } =========================================================References:  http://www. legendu. net/en/blog/lvalue-rvalue-reference/ https://www. learncpp. com/cpp-tutorial/15-2-rvalue-references/ https://www. fluentcpp. com/2018/02/06/understanding-lvalues-rvalues-and-their-references/Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day! "},{id:22,url:"https://techmunching.com/move-semantics-in-c-part-1/",title:"Move Semantics in C++\xa0: Part 1",
body:"2020/03/22 - Prerequisites: Understanding of rvalue references What are rvalues?:  RValue references represent modifiable object where the value is no longer needed so that you can steal their content and provide move semantics. Table of Contents:  Where does move semantics work? The difference in C++03/C++98 vs C++11 How to enable Move Semantics Default C++ support for Move Semantics How to forward Move Semantics Perfect Forwarding Move semantics and default Template ArgumentsWhere does Move Semantics work?: std::vector createAndInsert() { std::vector retval; retval. reserve(3); std::string val( temp ); // Step 1  retval. push_back(val); // C++98/03 : insert a copy of s into coll  // C++11. : same  // Step 2  retval. push_back(val + val); // C++98/03 : insert copy of temp val+val, destroy temp value  // C++11. : move val+val  // Step 3  retval. push_back(std::move(val)); // move explicitly // Step 4  return retval; // C++98/03 : may copy call  // C++11. : may move call }std::vector vec;  vec = createAndInsert();Final Memory footprint after createAndInsert() function call The difference in C++03/C++98 vs C++11: Containers have value semantics i. e. copy passed new elements into their containers but they allow to pass values which lead to unnecessary copies with C++98/C++03. As a contrast, with rvalue references, you can provide move semantics in C++11. For e. g. following has been added in vector class in C++11 \u2014 template class vector { public:    . . .   // insert a copy of elem:    void push_back(const T &amp; elem);  . . .     // insert elem with its content moved: // Introduced in C++11  void push_back(T &amp;&amp; elem);  . . . };How to enable Move Semantics:  To support move semantics for non-trivial types you should allow to    Steal contents from the passed object  Set the assigned object in a valid but undefined (or initial) state.  by providing a move constructor and a move assignment operator. A sample move constructor for string class is as below \u2014 class string { private:  int len; // current number of characters   char * elems; // array of characters   public:   // create a full copy of s:  string(const string &amp; s): len(s. len) {  elems = new char[len + 1]; // new memory   memcpy(elems, s. elems, len + 1); } // Move Constructor  // create a copy of s with its content moved:   string(string &amp;&amp; s): len(s. len), elems(s. elems) {   // copy pointer to memory    s. elems = nullptr;   // otherwise destructor of s frees stolen memory     s. len = 0;  }  . . . };However, primitive types don\u2019t get any benefit out of move class cannot_benefit_from_move_semantics {  int a; // moving an int means copying an int  float b; // moving a float means copying a float  double c; // moving a double means copying a double  char d[64]; // moving a char array means copying a char array   // . . .  };Default C++ support for Move Semantics:  Default Move Support \u2014 For library objects \u201cUnless otherwise specified, moved-from objects shall be placed in a valid but unspecified state. \u201d.  Copy as Fallback - If no move semantics is provided, copy semantics is used.  Move is very much needed \u2014 If move constructor is declared as deleted, the program may be ill-formed (not in C++17) Default move operations \u2014 Move constructor and Move assignment operator are generated only if there is no special member function defined among \u2014 \u2022 Copy constructor \u2022 Assignment operator \u2022 DestructorHow to forward Move Semantics: forwarding needs to done explicitly ===========================================================class X;void g (X&amp;); // for variable values  void g (const X&amp;); // for constant values  void g (X&amp;&amp;); // for values that are no longer used (move semantics) ===========================================================void f(X &amp; t) { g(t); // t is non const lvalue =&gt; calls g(X&amp;)  }void f(const X &amp; t) { g(t); // t is const lvalue =&gt; calls g(const X&amp;)  }void f(X &amp;&amp; t) { g(std::move(t)); //non-const lvalue needs ::move(), calls g(X&amp;&amp;)  }===========================================================Examples ===========================================================X v;const X c;1. f(v); // calls f(X&amp;) =&gt; calls g(X&amp;)  2. f(c); // calls f(const X&amp;) =&gt; calls g(const X&amp;)  3. f(X()); // calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;)  4. f(std::move(v)); // calls f(X&amp;&amp;) =&gt; calls g(X&amp;&amp;) ===========================================================Perfect forwarding: Special semantics for &amp;&amp; with template types, are known as \u201cUniversal Reference\u201d (standard term known as \u201cForwarding Reference\u201d)  You can use std::forward() to keep this forwarding semantics ===========================================================class X;void g(X &amp; ); // for variable values  void g(const X &amp; ); // for constant values  void g(X &amp;&amp; ); // for values that are no longer used (move semantics)template &lt; typename T &gt; void f(T &amp;&amp; t) // t is universal/forwarding reference { g(std::forward(t)); // forwards move semantics   // (without forward, only calls g(const X&amp;) or g(X&amp;)) }===========================================================X v;  const X c; f(v); f(c);  f(X());  f(std::move(v)); // All f(. . ) call work fineMove semantics and default Template Arguments: Now the question would be why can\u2019t we just use directly universal reference in our class copy/move constructors. The reason behind that is once Type deduction has taken place, \u201c&amp;&amp;\u201d even though templated, is no longer a universal reference. So basically template &lt;typename T&gt; void f (T&amp;&amp; t) // t is universal/forwarding reference {  . . .  }===========================================================template&lt;typename T&gt; class Widget {  . . .  Widget(Widget&amp;&amp; rhs);  // fully specified parameter type \u21d2 no type deduction  // hence &amp;&amp; \u2261 rvalue reference here};} ===========================================================   template&lt;typename T1&gt; class Gadget {  . . .  template&lt;typename T2&gt;  Gadget(T2&amp;&amp; rhs);  // deduced parameter type \u21d2 type deduction;  // hence &amp;&amp; \u2261 universal reference};} =========================================================== This is why all params can\u2019t be used to be forwarded easily as that requires multiple definitions for each argument to de deduced separately and further need default call + default template arguments. Another issue with default template arguments is that they are better match than pre-defined copy constructor for non-const objects \u2014 Using forwarding references only - The problem class Cust { private:  std::string first;  std::string last;  long id; public:  //better match than pre-defined copy constructor for non-const objects   template &lt; typename STR1, typename STR2 = std::string &gt;  Cust(STR1 &amp;&amp; fn, STR2 &amp;&amp; ln =   , long i = 0):    first(std::forward &lt; STR1 &gt; (fn)),   last(std::forward &lt; STR2 &gt; (ln)),   id(i) {}      . . . }; std::vector v;  v. push_back(Cust( Tim , Coe ,42)); // OKCust c( Joe , Fix ,77);  v. push_back(c); // OKCust d1{ Tina };    // OK  const Cust d2{ Bill }; // OK  Cust e1{d1};      // Error:can't convert Cust to string Cust e2{d2};      // OKIf member templates can be used as copy/move constructor or assignment operator, overload the first argument instead of using a template parameter, which is an easier and performant way to have move semantics. Using forwarding references, a performant way class Cust { private:  std::string first;  std::string last;  long id; public:  template &lt; typename STR2 = std::string &gt;  Cust(const std::string &amp; fn, STR2 &amp;&amp; ln =   , long i = 0):    first(fn), last(std::forward(ln)), id(i) {}    template &lt; typename STR2 = std::string &gt;  Cust(std::string &amp;&amp; fn, STR2 &amp;&amp; ln =   , long i = 0):    first(std::move(fn)), last(std::forward(ln)), id(i) {}    . . . };std::vector v;  v. push_back(Cust( Tim , Coe ,42)); // OK Cust c( Joe , Fix ,77);  v. push_back(c); // OK Cust d1{ Tina }; // OK  const Cust d2{ Bill }; // OK  Cust e1{d1}; // OK  Cust e2{d2}; // OKAnother safe way can be // Safe but non-performant way class Cust {    Cust(std::string fn, std::string ln = \u201c\u201d, long i = 0) :    first(std::move(fn)), last(std::move(ln)), id(i)    {     // . . .   }  };References:  Modern C++ \u2014 Dreams and Nightmares by Nicolai M. Josuttis what-is-move-semantics"},{id:23,url:"https://techmunching.com/find-the-element-that-appears-once-in-array-but-other-elements-appear-thrice/",title:"Find the element that appears once in array but other elements appear thrice",body:"2020/01/26 -  Problem: Given an array that contains integers. The content is such that every integer occurs 3 times in that array leaving one integer that appears only once. Find out the fastest way to find that single integer \u2014 not using any auxiliary memory. Example: Input: arr[] = {12, 1, 12, 3, 12, 1, 1, 2, 3, 3}Output: 2In the given array all element appear three times except \u20182\u2019 which appears once. XOR Thoughts: I know what you\u2019re thinking. Seems fine, we\u2019d do some XOR stuff and get the answer. Um. . yes but not that straightforwardly. Had the problem been simple such as \u2014  \u201cFinding the element which appears once in an array \u2014 containing other elements each appearing twice\u201d. Solution was to XOR all the elements and you get the answer. Basically, it makes use of the fact that x^x = 0. So all paired elements get XOR\u2019d and vanish leaving the lonely element. How you ask \u2014 Well bitwise XOR is \u2014  Associative \u2014 a ^ b ^ c = (a ^ b)^c = a ^(b ^ c) Commutative \u2014 Irrespective of what fashion elements appear in the array. Trick: Now, in the current question \u2014 if we apply the above idea, it will not work because \u2014 we got to have every unique element appearing even number of times. So instead of getting the answer, we will end up getting XOR of all unique elements which isn\u2019t exactly what we want. To rectify this problem, the solution makes use of 2 variables. 1) ones \u2014 At any point in time, this variable holds XOR of all the elements which have appeared only once. 2) twos \u2014 At any point in time, this variable holds XOR of all the elements which have appeared only twice. So if at any point time,  A new number appears \u2014 It gets XOR\u2019d to the variable \u201cones\u201d.  A number gets repeated(appears twice) \u2014 It is removed from \u201cones\u201d and XOR\u2019d to the variable \u201ctwos\u201d.  A number appears for the third time \u2014 It gets removed from both \u201cones\u201d and \u201ctwice\u201d. The final answer we want is the value present in \u201cones\u201d \u2014 because, it holds the unique element. Final Solution and explanation: Code for the solution in basic C++ would go something like this \u2014 int main() { int B[] = {  1,  1,  1,  3,  3,  3,  20,  4,  4,  4 }; int ones = 0; int twos = 0; int not_threes; int x; for (i = 0; i &lt; 10; i++) {  x = B[i];  twos |= ones &amp; x; // Step 1  ones ^= x; // Step 2   not_threes = ~(ones &amp; twos); // Step 3   ones &amp;= not_threes; // Step 4   twos &amp;= not_threes; // Step 5  } printf( \n unique element = %d \n , ones); return 0;}Step 1 and Step 2: New Element: Let\u2019s say a new element(x) appears \u2014 \u201cones\u201d and \u201ctwos\u201d haven\u2019t recorded \u201cx\u201d.  twos| = ones &amp; xAND condition yields nothing. So \u201ctwos\u201d doesn\u2019t get bit representation of \u201cx\u201d. But the next step ends up adding bits of \u201cx\u201d in \u201cones\u201d.  ones ^= xStep 1 and Step 2: Second Time Element: Let\u2019s say an element(x) appears the second time. Now \u201cones\u201d has recorded \u201cx\u201d but not \u201ctwos\u201d.  twos| = ones &amp; x\u201ctwos\u201d ends up getting bits of x. But due to the statement,  ones ^= x\u201cones\u201d removes \u201cx\u201d from its binary representation. Step 1 and Step 2: Third Time Element: Let\u2019s say an element(x) appears for the third time. Then \u201cones\u201d does not have bit representation of \u201cx\u201d but \u201ctwos\u201d has. \u201cones &amp; x\u201d yield nothing . . \u201ctwos\u201d by itself has bit representation of \u201cx\u201d. So after this statement, \u201ctwo\u201d has bit representation of \u201cx\u201d. Due to  ones^=xafter this step, \u201cone\u201d also ends up getting bit representation of \u201cx\u201d. Step 3, 4, and 5:: The last 3 lines of code convert common 1\u2019s between \u201cones\u201d and \u201ctwos\u201d to zeros. So if an element has appeared once or twice, the last three lines do nothing. If an element appears third time, last 3 lines of code remove common 1\u2019s of \u201cones\u201d and \u201ctwos\u201d \u2014 which is the bit representation of \u201cx\u201d. Thus both \u201cones\u201d and \u201ctwos\u201d end up losing bit representation of \u201cx\u201d. The final answer we want is the value present in \u201cones\u201d \u2014 because, it holds the unique element. A dry run of the solution:  1st example  \u2014 \u2014 \u2014 \u2014 \u2014 \u2014   2, 2, 2, 4 After first iteration,  ones = 2, twos = 0  After second iteration,  ones = 0, twos = 2  After third iteration,  ones = 0, twos = 0  After fourth iteration,  ones = 4, twos = 0 2nd example  \u2014 \u2014 \u2014 \u2014 \u2014 \u2014   4, 2, 2, 2 After first iteration,  ones = 4, twos = 0  After second iteration,  ones = 6, twos = 0  After third iteration,  ones = 4, twos = 2  After fourth iteration,  ones = 4, twos = 0References::  Careercup"},{id:24,url:"https://techmunching.com/git-merge-vs-git-rebase/",title:"Git merge vs Git Rebase",body:"2019/11/16 - A complete discussion about git rebase vs git merge (and squash merge) Table of Contents:  Introduction Git non fast-forward merge (A Type of Explicit Merge) Git fast-forward merge(A Type of Implicit Merge) Git Rebase (Another Type of Implicit Merge) Git squash merge (An Explicit Merge followed by rebasing or fast forward) Why such concern over rebase? A practical example GuidelineIntroduction: In Git, there are two prominent ways to converge multiple branches of development \u2014 git merge and rebase. With all the references from the experts and articles, everyone believes \u201cRebase could cause serious problems. \u201d so we will discuss what merge and rebase strategies are? How to perform them, which one to choose and when? Git Merge: Merging takes the contents of a source branch and integrates them with a target branch.  Merge is always a forward-moving change record Merging (except squash) is non-destructive, commit Ids are not changed in any way. 1. Explicit git merge (a. k. a non fast forward merge):  Explicit merge creates a new commit. That is a very important thing to remember and one that is elusive to the newcomers. It is a simple commit with one difference \u2014 it has two parents. All other regular commits have only one. How do you check that? Fire up the terminal and a merge commit would look like below in git log .  commit 229b6993346adae1e5b095c356b4af11dd1bb9da  Merge: 7222f6a c952e91  Author: Pranay Kumar &lt;pranayaggarwal25@gmail. com&gt;  Date: Sat Oct 19 20:24:00 2019 +0530 Merge branch 'master' of github. com:pranayaggarwal/enumifier     Your browser does not support the video tag.  Sample animation for Explicit git merge Pros:  Preserves complete history and chronological order. Cons:  Commit history can become polluted by lots of merge commits.  Debugging using git bisect can become harder. 2. Implicit git merge via fast forward merge:  It can only happen if there are no more commit made in source i. e. HEAD is not diverged. That\u2019s why the implicit merge can be completed without an explicit merge commit: it literally just fast-forwards the branch label to the new commit as shown below.      Your browser does not support the video tag.  Sample animation for Implicit git merge Pros:  No extra commit is made so commit history doesn\u2019t get polluted.  Converges possibly capable of being merged branches in a cleaner way. Cons:  Fast forward merge will still lose some context of those commits as part of an earlier feature branch. How to do git merge: In the event that you require a merge commit during a fast forward merge for record-keeping purposes, you can execute git merge with the \u2013no-ffoption. git merge \u2014 no-ff vs git merge Merge the master branch into the feature branch using the checkout and merge commands. $ git checkout feature $ git merge master(or)$ git merge master featureThis will create a new \u201cMerge commit\u201d in the feature branch that holds the history of both branches. Git Rebase (Implicit merge via rebase way): Rebase is recreating your work from one branch onto another.      Your browser does not support the video tag.  Read this again, slowly: new commit for every old one, with the same changes.      Your browser does not support the video tag.  Sample animation for git rebase Used this way, one can indeed apply some commits to master without creating a merge commit. This procedure completely loses the context of where those commits come from, unfortunately. Pros:  Streamlines a potentially complex history Manipulating a single commit is easy (e. g. reverting) Avoids merge commit \u201cnoise\u201d with busy branches. Cons:  Squashing the feature down to a handful of commits can hide the context Rebasing public repositories can be dangerous when working as a team.  It\u2019s more work, Rebasing with remote branches requires you to force push. The biggest problem people face is they force push but haven\u2019t set git push default. This results in updates to all branches having the same name, both locally and remotely, and that is dreadful to deal with. Interactive Rebasing: This allows altering the commits as they are moved to the new branch. Typically this is used to clean up a messy history before merging a feature branch into master How to do it: Rebase the feature branch onto the master branch using the following commands.  $ git checkout feature  $ git rebase master // use with -i option for interactiveGit squash merge: (usually followed by implicit merge): A third way to move changes is to squash all feature branch\u2019s commits into a single commit before performing an implicit merge fast-forward merge or rebase.      Your browser does not support the video tag.  Sample animation for squash merge If you use explicit merges this need does not arise because the explicit merge commit allows you to reconstruct what was in the feature branch and its entire evolution. Pros:  Keeps the mainline branch history linear and clean It isolates the entire feature in a single commit.  If used with a fast-forward merge, it can give you an advantage of both explicit merge and rebase. Cons:  It loses insight and details on how the feature branch developed throughout.  You might be compelled to keep the original, unsquashed, feature branch around for historical reasons. How to do it:  $ git merge --squash feature  // After this you would need to explicitly commit this squashed commitWhy such concern over rebase?:  Merge preserves history whereas rebase rewrites it. Consider the case where a dependency that is still in use on feature has been removed on master. When feature is being rebased onto master, the first re-applied commit will break your build, but as long as there are no merge conflicts, the rebase process will continue uninterrupted. The error from the first commit will remain present in all subsequent commits, resulting in a chain of broken commits. This error is only discovered after the rebase process is finished, and is usually fixed by applying a new bugfix commit g on top. Example of failed rebasing Even If you do get conflicts during rebasing however, solving conflicts in the middle of rebasing a long chain of commits is often confusing, hard to get right, and another source of potential errors. This way, new errors are introduced when you rewrite history, and they may disguise genuine bugs that were introduced when history was first written. In particular, this will make it harder to use Git bisect which performs a bisection search through the history, identifying the commit that introduced the bug \u2014.  git bisect run &lt;yourtest. sh&gt;     Your browser does not support the video tag.  Example of a failed Git bisect if we\u2019ve introduced additional broken commits during rebasing (here, d and e), bisect will run into trouble. In this case, we hope that Git identifies the commit f as the bad one, but it erroneously identifies dinstead, since it contains some other error that breaks the test. Guideline: Use rebase when:  You have a need to merge local changes and don\u2019t need an exact history. Why litter it with merge commits? You prefer a linear history and use git bisect very often (it can get confused with a non-linear history). Use merge when:  You have shared some of the changes with others and it\u2019s important not to break their repositories. git rebase changes a lot of history so a normal merge is much safer and cleaner for others.  You care about history and development tracks. Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day!References:  A successful Git branching model Git merge debate Why you should stop using Git rebase"},{id:25,url:"https://techmunching.com/unnamed-anonymous-namespaces-vs-namespace-static/",title:"Unnamed anonymous namespaces vs namespace static",body:"2019/11/10 - Detailed Comparison of unnamed namespaces and namespace static with advantages and disadvantages  Photo by Jens Lelie on Unsplash Table of Contents:  Translation unit unnamed namespaces static and namespace-static usage for both Where anonymous namespaces are superior Where namespace static pays off SummaryTranslation Unit: According to standard C++ (wayback machine link)  A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements. Unnamed namespace: A feature of C++ is the ability to create unnamed (anonymous) namespaces, like so: namespace {  int invisible_to_others_translation_unit() { . . . }} // namespaceThese unnamed namespaces are accessible within the translation unit they\u2019re created in as if you had an implicit using-clause to them. An unnamed-namespace-definition behaves as if it were replaced by  inline namespace unique { /* empty body */ }  using namespace unique ;  namespace unique { [*namespace-body*] } Members of an inline namespace are treated as if they are members of the enclosing namespace. Static and namespace-static: The static keyword can be used to declare variables and functions at -  global scope \u2014 variables and functions namespace scope \u2014 variables and functions class scope \u2014 variables and functions local scope \u2014 variablesStatic duration means that the object or variable is allocated when the program starts and is deallocated when the program ends. External linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program. Internal linkage means everything in the scope of a translation unit. By default, an object or variable that is defined in the global namespace has the static duration and external linkage however when you declare a variable or function at file scope (global and/or namespace scope), the static keyword specifies that the variable or function has internal linkage. // in namespace or global scopeint i; // extern by default const int ci; // static by default extern const int eci; // explicitly extern static int si; // explicitly static // ========================================================== //// same goes for functions (but there are no global const functions)int foo(); // extern by default static int bar(); // explicitly static const variables goes by default internal linkage unless otherwise declared as extern.  Static data members/member function/unnamed class/named class/enumeration of a class in namespace scope have same linkage as the enclosing class.  A class template has the linkage of the innermost enclosing class or namespace in which it is declared.  Specializations (explicit or implicit) of a template that has internal linkage are distinct from all specializations in other translation units. Static usage vs anonymous namespace: namespace test{   static int i = 5; // internal linkage, definition is here   // And there will be no multiple definition!  }if you remove static, multiple definition errors would surely come. vs namespace {   int i = 5; // default internal linkage, unreachable from other   // translation units.   class invisible_to_others { };  }Where anonymous namespaces are superior: 1. namespaces work for everything: An unnamed namespace is superior to the static keyword, primarily because of the fact that keyword static applies only to the variables declarations and functions, not to the user-defined types. The following code is valid in C++ //legal code static int sample_function() { /* function body */ } static int sample_variable;But this code is NOT valid //illegal code static class sample_class { /* class body */ }; static struct sample_struct { /* struct body */ };So the solution is, unnamed-namespace, which is this, //legal code namespace  {   class sample_class { /* class body */ };  struct sample_struct { /* struct body */ }; }2. static has too many meanings: a) namespace-static \u2014 internal linkageb) local-static \u2014 local variable persistencec) member-static \u2014 class method 3. Uniformity and consistency: Namespaces provide a uniform and consistent way of controlling visibility at the global scope. You don\u2019t have to use different tools for the same thing. 4. For template arguments: C++ does not allow types and pointers/references to objects or functions with internal linkage (static) to be used as template parameters. Where static in namespaces pays off: 1. Specialization of templates:  anonymous namespaces can\u2019t specialize templates outside of the namespace block static keyword makes every translation unit which includes the interface header that contains namespace declaration has an internal-linkage copy of the static variable/function (consumes space). Hence, no multiple definition error. The same for const with no extern preceding it which defines a variable of internal linkage. 2. A cleaner Global Symbol Table: static prevent the name from entering into the global symbol table. This is strictly an optimization, but an important one in practice. This property is not shared by names in the unnamed namespace.  Functions in unnamed namespaces, however, generally are added to the symbol table but marked as internal or mangled so that they are effectively inaccessible. So, in general, a program that uses static for its translation-unit-local namespace-level functions generates less work for the linker and might execute faster than the equivalent program using the unnamed namespace.      Your browser does not support the video tag.  Summary: Avoid working with anonymous namespaces if you\u2019re working with headers. Due to default internal linkage, each translation unit will define its own unique instance of members of the unnamed namespace which can cause unexpected results, bloat the resulting executable, or inadvertently trigger undefined behavior due to one-definition rule (ODR) violations. Stating that variables defined in the anonymous namespaces are implicitly static is wrong and static are not totally useless in namespaces. In general, you can go to this guideline.  Prefer free functions and types in anonymous namespace (unless in header files, then go for static).  If needed to specialize class template methods or linker optimizations are a major concern, static is the option to go for. Unnamed namespaces are designed for protecting locality rather than offering an interface. Bonus Question 1: namespace { class A { } ; }  void foo ( A ) // _Z3fooN12_GLOBAL__N_11AE { ; }the function\u2019s symbol, apparently, would refer to the name of A, which is a member of a uniquely named namespace. what is the foo\u2019s linkage. ? Answer: While the name foo technically has external linkage, it cannot actually be referred to by other translation units since there is no way to write the name of the type of foo\u2019s parameter References:  linkage of function with parameter from unnamed namespace DCL59-CPP. Do not define an unnamed namespace in a header fileThanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article. Please check out our other articles and website, Have a great day! "},{id:26,url:"https://techmunching.com/10-awesome-git-tricks-an-advanced-cheatsheet/",title:"10 Awesome Git Tricks: An advanced cheatsheet",
body:"2019/10/21 - Commit, Branching, Refs, Checkouts, push and pulls Photo by Yancy Min on Unsplash Table of Contents: 1) Refs2) Better Commits3) Easier Checkouts4) A nicer force push5) Search in Git logs6) Submodule handling7) Empty commit (to trigger something maybe)8) Better Patches9) Better branch handling10) Create local origin branch from remote 1) Refs:  HEAD^  # 1 commit before head  HEAD^^  # 2 commits before head  HEAD^^^^ # 4 commits before head  HEAD~5  # 5 commits before headSample usage: git show HEAD~2 This will show specified commit\u2019s summary and diff. 2) Better Commits: To make sure each commit consists of only a single logical change, to divide things up so that each commit contains only the appropriate changes? git add \u2013patch to the rescue!!  git add -p # output will be. . . . .  # . . . . . &lt;file diff&gt; Stage this hunk [y,n,q,a,d,e,?]?This flag will cause the git add command to look at all the changes in your working copy and, for each one, ask if you\u2019d like to stage it to be committed, skip over it, or defer the decision (as well as a few other more powerful options you can see by selecting after running the command). 3) Easier Checkouts: Similar to git add -p, the git checkout command will take a \u2013patch or -p option, which will cause it to present each \u201chunk\u201d of change in your local working copy and allow you to discard it. This is fantastic when, for example, you\u2019ve introduced a bunch of debug logging statements while chasing down a bug. After the bug is fixed, you can use it!  git checkout -p # output will be  . . . . .   . . . . . &lt;file diff&gt; Discard this hunk from worktree [y,n,q,a,d,e,?]?4) A nicer force-push: No matter how hard as you try to avoid it, sometimes git push \u2013force to overwrite the history on a remote copy of your repository becomes necessary. You may have gotten some feedback that caused you to do an interactive rebase, or you may simply have messed up and want to hide the evidence. One of the hazards with force pushes happens when somebody else has made changes on top of the same branch in the remote copy of the repository. When you force-push your rewritten history, those commits will be lost. This is where the following option comes in, it will not allow you to force-push if the remote branch has been updated, which will ensure you don\u2019t throw away someone else\u2019s work. Ain\u2019t it nice? git push \u2013force-with-lease 5) Search in Git logs:  git log --grep= fixes things  # search in commit messages  git log -S window. alert  # search in code6) Submodules:  # Import . gitmodules  git submodule init# Clone missing submodules, and checkout commits  git submodule update --init --recursive# Update remote URLs in . gitmodules  # (Use when you changed remotes in submodules)  git submodule update --remote # To override local submodule change  git submodule update --remote --force7) Empty Commit (to trigger something maybe):  git commit --allow-empty -m \u201cTrigger notification\u201d8) Better Patches: Trygit format-patch -1 OR git format-patch -1 HEAD The -1 flag tells git how many commits should be included in the patch; git format-patch -1 HEAD Apply the patch with the command:  git am &lt; file. patch  # OR  git apply xyz. patch9) Better branch handling: Create the branch and checkout:  git checkout -b &lt;branch_name&gt;   # -b for creating the branch if not existsDelete branch locally and on remote  #Local delete  git branch -D &lt;branch_name&gt; # -D for forceful delete, -d for soft #Push deletion on remote and thus deleting the remote branch  git push &lt;remote_name&gt; --delete &lt;branch_name&gt;Delete remote branch 10) Create local origin branch from remote:  git fetch origin  git checkout -b &lt;remote_branch_name&gt; origin/&lt;remote_branch_name&gt;References: https://stackoverflow. com/a/23961231https://opensource. com/article/18/4/git-tips Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comment to improve this article. Please check out our other articles and website Have a great day! "},{id:27,url:"https://techmunching.com/create-and-manage-multiple-github-accounts/",title:"Create and manage multiple GitHub accounts",body:"2019/10/14 - Managing personal and professional Github Account simultaneously Managing Git Say you have a personal GitHub account, everything is working perfectly fine. For managing the coexistence of your professional account (enterprise Github) and your personal account, you would need to have the ability to push and pull to multiple accounts. Let\u2019s see how! Table Of Contents:  Generating the SSH keys Attach the New Key to corresponding GitHub account Registering the new SSH Keys with the ssh-agent Finally Creating the SSH config file Try it OutStep 1\u2013Generating the SSH keys: Before generating an SSH key, we should always check existing SSH keys:ls -al ~/. ssh If ~/. ssh/id_rsa is available, we can reuse it, or else we can first generate a key to the default ~/. ssh/id_rsa by running: ssh-keygen -t rsaWhen asked for the location to save the keys, accept the default location by pressing enter. A private key and public key ~/. ssh/id_rsa. pub will be created at the default ssh location ~/. ssh/. Let\u2019s use this default key pair for our personal account. cd ~/. ssh ssh-keygen -t rsa -b 4096 -C  your_personal_email@domain. com   # save as id_rsa_personal ssh-keygen -t rsa -b 4096 -C  your_work_email@domain. com  # save as id_rsa_work, you would have two different keys created ~/. ssh/id_rsa_personal ~/. ssh/id_rsa_workThe files with the . pub extension are the public files that you would add to your GitHub account. Now you should have something like \u2014 id_rsa_personal id_rsa_personal. pub id_rsa_work id_rsa_work. pubStep 2 \u2014 Attach the New Key to corresponding GitHub account: We already have the SSH public keys ready, and we will ask our GitHub accounts to trust the keys we have created. This is to get rid of the need for typing in the username and password every time you make a Git push. Copy the public key pbcopy &lt; ~/. ssh/id_rsa_personal. pub and then log in to your personal GitHub account:  Go to Settings Select SSH and GPG keys from the menu to the left.  Click on New SSH key, provide a suitable title, and paste the key in the box below Click Add key \u2014 and you\u2019re done! For the work accounts, use the corresponding public keys (pbcopy &lt; ~/. ssh/id_rsa_work. pub) and repeat the above steps in your GitHub work accounts. Step 3 \u2014 Registering the new SSH Keys with the ssh-agent: To use the keys, we have to register them with the ssh-agent on our machine. Ensure ssh-agent is running using the command eval \u201c$(ssh-agent -s)\u201d. Add the keys to the ssh-agent like so: ssh-add -D // clears order keys, if any ssh-add ~/. ssh/id_rsa_personal ssh-add ~/. ssh/id_rsa_workStep 4 \u2014 Finally Creating the SSH config file: We\u2019ve done the bulk of the workload, but now we need a way to specify when we wish to push to our personal account, and when we should instead push to our company account. To do so, let\u2019s create a config file. touch ~/. ssh/config // Creates the file if not exists vim config // Opens the file in VIM editor code config // Opens the file in VS code, use any editorIf you\u2019re not comfortable with Vim, feel free to open it within any editor of your choice. Paste in the following snippet. # Personal account, - the default config Host github. com  HostName github. com  User git  Port 443  IdentityFile ~/. ssh/id_rsa_personal   # Work account-1 Host git. corp. &lt;work_url&gt;. com  HostName git. corp. &lt;work_url&gt;. com  User git  Port 443  IdentityFile ~/. ssh/id_rsa_workCreate the work specific git config (if not already created) touch ~/. gitconfigand add following snippet . . . .  . . . . [user]  name = Your Name  email = [w](mailto:pranayku@adobe. com)work_email@work. com [includeIf  gitdir:~/work_folder/ ]  path = ~/work_folder/. gitconfig The above configuration uses Conditional includes introduced in git 2. 13 to handle multiple configurations. Alternatively, to add the config name and email, do git config user. name and git config user. email.  git config user. name  Your Name  // Updates git config user name  git config user. email  work_email@work. com Create the personal specific git config: $ nano ~/Personal/. gitconfigand add \u2014 [user]  email = personal_email@gmail. comStep 5\u2014 Try it Out: Proceed to authenticate the keys with GitHub using the commands below: $ ssh -T github. com # Hi USERNAME! You've successfully authenticated, but GitHub does not provide shell access. $ ssh -T git. corp. work. com # Hi USERNAME! You've successfully authenticated, but GitHub does not provide shell access. Repositories can be cloned using the clone command Git provides: git clone git@github. com:personal_account_name/repo_name. gitThe work repository will require a change to be made with this command: git clone git@git. corp. work. com:work_user1/repo_name. gitThanks for reading this article! Feel free to leave your comments and let us know what you think. Please feel free to drop any comment to improve this article. Please check out our other articles and website Have a great day! "},{id:28,url:"https://techmunching.com/smart-observer-pattern-in-c/",title:"Smart Observer Pattern in C++",body:"2019/10/13 - smarter pub-sub A better event dispatcher Photo by Fotis Fotopouloson unsplash. com Usual Implementation problem:  Typical Event subscriptions where observers (or listeners) register with a subject (or publisher) to receive events have a usual issue in most implementations which is commonly known as the Lapsed listener problem This requires explicit deregistration, as in the typical dispose pattern paradigm.  The leak happens when an observer fails to unsubscribe from the subject when it no longer needs to listen. Consequently, the subject still holds a strong reference to the observer which prevents it from being garbage collected. The Usual Resolution Mechanism:  This can be prevented by the subject holding weak references to the observers, allowing them to be garbage collected as normal without needing to be unregistered.  Thus the idea is to keep only the std::weak_ptr in event dispatcher and do the (lazy) cleanup on event invocation.    Probably something along the lines of -Approxmiate event dispatcher: common resolution mechanism   And a simple notifier would look something like thisSample Notifier for the event dispatcher OR we can opt for the classic \u201cerase and update\u201d using iterator based loop and merge these two loop operation(s).  There is an issue with this approach, what\u2019s that?What seems to be the problem? The Trouble in Paradise:  What if the observer tries to update you while being notified ???Suppose something in an observer you fire, ends up in -  Adding or removing observers? =&gt; Bad (includes crashes!) Blocking the action of another thread, who blocks on trying to add an observer? =&gt; Bad (deadlocks!)NooooooBasically the problem is with Reentrancy here.  Never, ever leave control of your code while holding the lock.  Holding a lock and calling a callback is a no-no. Tying the loose ends (Simple fix): \u201cCopy and Broadcast\u201d \u2014 While copying, remove expired observers (from original and hence excluded from the copy), then fire off observers from the copied list. After this fix, a notifier would roughly look something like - Copy And Broadcast mechanism Tying the loose ends (Better but complex fix):  Maintaining a non-blocking lock-free task queue that includes add/remove/notify etc. events.  In case the event handlers take good amount of time, it might be considered launching them \u201call at once\u201d, i. e. in their own threads over which join takes place, or maybe using executor mechanism etc. TL;DR: "},{id:29,url:"https://techmunching.com/a-tale-of-two-allocations/",title:"A tale of two allocations",body:"2019/10/12 - make_shared vs shared_ptr Quick Recap:: Just a quick recap, shared pointers work on the concept of ref count, they maintain a separate control block that stores these count. The way shared_ptr works is that they maintain - strong reference count (S) \u2014 number of shared_ptr(s) keeping the object alive. The shared object is destroyed (and possibly deallocated) when the last strong ref goes away. weak reference count (W) \u2014 number of active weak_ptr(s) currently observing the object + (S!=0) Strong and weak count  Strong and Weak count(s) are typically incremented using an equivalent of atomic::fetch_add with memory_order_relaxed. Decrementing requires stronger ordering to ensure safe destruction. Logical model for shared_ptr constructor: If a shared_ptr is constructed from an existing pointer that is not shared_ptr the memory for the control structure has to be allocated. Approximate Memory Lyaout This Control block is destroyed and deallocated when the last weak ref goes away. A shared_ptr construction approach takes two steps 2 Step memory allocation approach Logical model for object construction using make_shared: make_shared (or allocate_shared) Allocates the memory for the control structure and the object itself in one single mem block. Approximate Memory LyaoutThe object is then constructed by perfectly forwarding the arguments to its constructor.  Pros make_shared over shared_ptr: Performance: Reduced number of separate allocations Cache locality: Actions that work with both the count structure and the object itself, will have only half the number of cache misses. (In case cache misses are big issue, we might want to avoid working with single object pointers altogether) Order of execution and exception safety: (concern pre-C++17) Sample Code A possible execution ordering is  1) new Lhs(\u201cfoo\u201d))2) new Rhs(\u201cbar\u201d))3) std::shared_ptr&lt;Lhs&gt;4) std::shared_ptr&lt;Rhs&gt; And one important advantage, especially in cases of preC++17 codes, is the execution safety. So look at this snippet. Foo has this function signature, you make the call like this. . now before c++17 there is no restriction of argument resolution so one of the possible resolution may look like this \u2014 now what is second step throws. . you have a leak, right? Fix 1: Use make_shared Use make_shared Fix 2: Code expansion Code expansion Pro shared_ptr vs. make_shared: Access to the constructor - make_shared needs access to the constructor it has to call Lifetime of the object storage (not the object itself) \u2014 The second advantage is about the lifetime of the object storage (not the object) this is about the destruction vs deallocation, when the last weak count goes off, then only deallocation would take place. In case of make_shared the single block becomes the bottleneck. For large size objects in association with some long life weak_ptr, this may become problematic. Approximate Memory Layout With shared_ptr, You can also specify a custom deleter, if needed! Conclusion : Unless good reason, follow this  As a guideline usually, make_shared is more preferable to shared_ptr, but there are cases as stated above where one might need shared_ptr as well. Choose well we must References:  https://arne-mertz. de"}],idx=lunr(function(){this.ref("id"),this.field("title"),this.field("body"),documents.forEach(function(e){this.add(e)},this)});</script> <style>.lunrsearchresult .title{color:#d9230f}.lunrsearchresult .url{color:silver}.lunrsearchresult a{display:block;color:#777}.lunrsearchresult a:hover,.lunrsearchresult a:focus{text-decoration:none}.lunrsearchresult a:hover .title{text-decoration:underline}</style> <form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);"> <input type="text" class="form-control text-small" id="lunrsearch" name="q" value="" placeholder="Search..."> </form> </ul> </div> </div> </nav> <div id="lunrsearchresults"> <ul class="mb-0"></ul> </div> <main role="main" class="site-content"> <div class="container"> <h3 class="font-weight-bold spanborder"><span>Privacy Policy</span></h3> <div class="page-content"> <p>“TechMunching” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used.</p> <h4 id="collection-of-routine-information">Collection of Routine Information</h4> <p>This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes.</p> <h4 id="cookies">Cookies</h4> <p>Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content.</p> <h4 id="advertisement-and-other-third-parties">Advertisement and Other Third Parties</h4> <p>Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to <a href="http://www.google.com/privacy_ads.html">opt out of Google’s cookie usage</a>.</p> <h4 id="links-to-third-party-websites">Links to Third Party Websites</h4> <p>We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own.</p> <h4 id="security">Security</h4> <p>The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security.</p> <h4 id="changes-to-this-privacy-policy">Changes To This Privacy Policy</h4> <p>This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page.</p> <p>We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website.</p> <h4 id="contact-information">Contact Information</h4> <p>For any questions or concerns regarding the privacy policy, please <a href="/contact.html">contact us here</a>.</p> </div> </div> </main> <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script> <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script> <script src="/assets/js/theme.js"></script> <script src="/assets/js/prism.js"></script> <footer class="bg-white border-top p-3 text-muted small"> <div class="container"> <div class="row align-items-center justify-content-between"> <div> <span class="navbar-brand mr-2 mb-0"><strong>TechMunching</strong></span> <span>Copyright © <script>document.write((new Date).getFullYear());</script></span> </div> <div style="display: flex;"> <div style="margin-left: 0%;" class="row align-items-center justify-content-between"><span>Made with <i class="fa fa-heart" aria-hidden="true" style="color:red;"></i> by TechMunching | </span></div><div style="padding-left: 0.3em;font-size: 1.2em;"><a style="font-size: 1em;" class="nav-link" href="/contact.html">Contact Us</a></div> </div> </div> </div> </footer> </body> </html>