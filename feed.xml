<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://techmunching.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://techmunching.com/" rel="alternate" type="text/html"/><updated>2021-02-15T13:47:34+00:00</updated><id>https://techmunching.com/feed.xml</id><title type="html">TechMunching</title><subtitle>Your daily tech snack</subtitle><entry><title type="html">No more dealing with slow MacBookPro</title><link href="https://techmunching.com/No-more-dealing-with-slow-MacBookPro/" rel="alternate" type="text/html" title="No more dealing with slow MacBookPro"/><published>2021-01-28T00:00:00+00:00</published><updated>2021-01-28T00:00:00+00:00</updated><id>https://techmunching.com/No-more-dealing-with-slow-MacBookPro</id><content type="html" xml:base="https://techmunching.com/No-more-dealing-with-slow-MacBookPro/">&lt;h1 id=&quot;heres-another-macbookpro-101-for-you&quot;&gt;Here’s another MacBookPro 101 for you!!&lt;/h1&gt; &lt;!-- ![](/img/throttle_1.gif) --&gt; &lt;div class=&quot;vidWrapper&quot;&gt; &lt;video style=&quot;max-width:100%&quot; autoplay=&quot;&quot; muted=&quot;&quot; loop=&quot;&quot;&gt; &lt;source src=&quot;/img/throttle_1.mp4&quot; type=&quot;video/mp4&quot; /&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;/div&gt; &lt;p&gt;Has it ever happened with you that you are all set to rock the virtual meeting with your presentation and just before sharing your MacBook’s screen, it froze? Not your heart but the Laptop, the trackpad isn’t anymore in control of the cursor, the fan is on full throttle, yet everything is all slowed down.&lt;/p&gt; &lt;p&gt;It’s not a hidden fact now that Apple throttles the CPU when your MacBook heats up. While this would have been a bearable scenario if heating up wasn’t necessarily an often scenario, but enough applications are running on our system to beat the shit out of it. This is even more common for my fellow developer friends.&lt;/p&gt; &lt;p&gt;Well, a good way out people might suggest to this would be to buy an M1 Chip MacBook Pro, if you can afford that it might be best to stop reading this blog further and visit a nearby apple store. However, if you have recently bought a MacBook Pro wouldn’t necessarily want to do that, please keep reading.&lt;/p&gt; &lt;p&gt;I suggest using the Macs Fan Control (http://crystalidea.com/macs-fan-control) application on your MacBook. This helps you control the fan speed without tying it with the current temperature.&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Install the application.&lt;/li&gt; &lt;li&gt;Right-click on MacsFanControl in TaskBar&lt;/li&gt; &lt;li&gt;Select Full Blast&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Here is what I suggest - Turn on the fan to full throttle and let your fan always work at full speed. This hack has allowed me to stay at peace and not worry about being slowed down in the best of moments.&lt;/p&gt; &lt;p&gt;Here is the snapshot of the settings your need to opt for:&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/throttle_2.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/throttle_3.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;I hope it helps my fellow mates.!&lt;/p&gt; &lt;p&gt;Please consider commenting on the post below what else would you like to read on our blog. We make weekly blogs about tech and more.&lt;/p&gt;</content><author><name>admin</name></author><category term="Productivity"/><summary type="html">Here’s another MacBookPro 101 for you!!</summary></entry><entry><title type="html">Largest sub matrix rectangle with rearrangement with all 1s</title><link href="https://techmunching.com/Largest-sub-matrix-rectangle-with-rearrangement-with-all-1s/" rel="alternate" type="text/html" title="Largest sub matrix rectangle with rearrangement with all 1s"/><published>2021-01-17T00:00:00+00:00</published><updated>2021-01-17T00:00:00+00:00</updated><id>https://techmunching.com/Largest-sub-matrix-rectangle-with-rearrangement-with-all-1s</id><content type="html" xml:base="https://techmunching.com/Largest-sub-matrix-rectangle-with-rearrangement-with-all-1s/">&lt;p&gt;We at Tech Munching provide you the cleanest, easy to understand solutions to difficult competitive coding questions. This question #1727 appeared in LeetCode contest #224.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/bricks.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;p&gt;&lt;em&gt;Here is the question:&lt;/em&gt;&lt;/p&gt; &lt;p&gt;You are given a binary matrix &lt;code&gt;matrix&lt;/code&gt; of size &lt;code&gt;m x n&lt;/code&gt;, and you are allowed to rearrange the &lt;strong&gt;columns&lt;/strong&gt; of the &lt;code&gt;matrix&lt;/code&gt; in any order.&lt;/p&gt; &lt;p&gt;Return &lt;em&gt;the area of the largest submatrix within&lt;/em&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;em&gt;where &lt;strong&gt;every&lt;/strong&gt; element of the submatrix is&lt;/em&gt; &lt;code&gt;1&lt;/code&gt; &lt;em&gt;after reordering the columns optimally.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png&quot; alt=&quot;https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png&quot; /&gt;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;Input: matrix = [[0,0,1],[1,1,1],[1,0,1]] Output: 4 Explanation: You can rearrange the columns as shown above. The largest submatrix of 1s, in bold, has an area of 4. &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;p&gt;&lt;em&gt;Here is our proposed solution:&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Not to console the audience reading it after the contest, however, this wasn’t necessarily a &lt;code&gt;medium&lt;/code&gt; problem. &lt;em&gt;As with life, this problem also has multiple solutions to it&lt;/em&gt;. So, please comment down in case you would need further solutions based on DP or so.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;Let’s try to look at the problem in a different way, can we think of &lt;code&gt;value 1&lt;/code&gt; as adding a floor to the building and &lt;code&gt;value 0&lt;/code&gt; as ground level of the building. Our task is to find the max rectangle with parallel buildings and because the columns can be rearranged, we can move the buildings.&lt;/p&gt; &lt;p&gt;Here are the height of the building for each row:&lt;/p&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 1&lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 2&lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 3&lt;/th&gt; &lt;th&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Row 1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row 2&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt; &lt;td&gt;(Previous floor adds up in coloumn 3)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row 3&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt; &lt;td&gt;(Ground floor in coloumn 2 nullifies previous height)&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/img/200117-row3.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;Since, we can actually move the coloumns, above rows after sorting can be represented as:&lt;/p&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 1&lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 2&lt;/th&gt; &lt;th style=&quot;text-align: center&quot;&gt;Col 3&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Row 1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row 2&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row 3&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt; &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;p&gt;&lt;br /&gt; &lt;img src=&quot;/img/200117-row31.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;Once you reach this state, finding the max rectangles for each building is height * width.&lt;/p&gt; &lt;p&gt;For example:&lt;/p&gt; &lt;p&gt;Row 3 &amp;amp; Col 1 : 3 (height) * 1 (width)&lt;/p&gt; &lt;p&gt;Row 3 &amp;amp; Col 1 &amp;amp; Col 2 : 2 (height) * 2 (width)&lt;/p&gt; &lt;p&gt;Here is complete solution:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class Solution { public: int largestSubmatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { if (matrix.empty()) return 0; vector&amp;lt;int&amp;gt; brickLevel (matrix[0].size(), 0); int answer = numeric_limits&amp;lt;int&amp;gt;::min(); for (auto i = 0; i &amp;lt; matrix.size(); i++) { for (auto j = 0; j &amp;lt; matrix[0].size(); j++) // set the brick value brickLevel[j] = matrix[i][j] == 0 ? 0 : brickLevel[j] + 1; // sort bricks to keep buildings consecutive auto mx = brickLevel; sort(mx.begin(), mx.end(), greater()); for (auto i = 0; i &amp;lt; mx.size(); i++) answer = max(answer, (i + 1) * mx[i]); } return answer; } }; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The time complexity for a matrix of &lt;code&gt;MxN&lt;/code&gt; will be &lt;code&gt;MNlog(N)&lt;/code&gt;. That’s easy to understand, the outer loop iterates M rows which iterates N columns and sort vector of length N which is &lt;code&gt;M * (N + Nlog(N))&lt;/code&gt;, which asymptotically is &lt;code&gt;MNlog(N)&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Please feel free to comment down below in case you find any flaw or would need deeper understanding in any aspects.&lt;/p&gt; &lt;hr /&gt;</content><author><name>admin</name></author><category term="C++"/><category term="Algorithm"/><category term="Interview Preparation"/><summary type="html">We at Tech Munching provide you the cleanest, easy to understand solutions to difficult competitive coding questions. This question #1727 appeared in LeetCode contest #224.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/bricks.webp"/><media:content medium="image" url="https://techmunching.com/img/bricks.webp" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Lambdas and closures in C++</title><link href="https://techmunching.com/lambdas-and-closures-in-c/" rel="alternate" type="text/html" title="Lambdas and closures in C++"/><published>2020-10-27T00:00:00+00:00</published><updated>2020-10-27T00:00:00+00:00</updated><id>https://techmunching.com/lambdas-and-closures-in-c</id><content type="html" xml:base="https://techmunching.com/lambdas-and-closures-in-c/">&lt;p&gt;What are closures vs how lambdas are different from closures?&lt;/p&gt; &lt;!-- ![](/img/0*PA8-5rLUUze-e0iK.gif) --&gt; &lt;div class=&quot;vidWrapper&quot;&gt; &lt;video style=&quot;max-width:100%&quot; autoplay=&quot;&quot; muted=&quot;&quot; loop=&quot;&quot;&gt; &lt;source src=&quot;/img/0*PA8-5rLUUze-e0iK.mp4&quot; type=&quot;video/mp4&quot; /&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;/div&gt; &lt;p&gt;&lt;em&gt;They look similar!!&lt;/em&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Just your everyday functions&lt;/li&gt; &lt;li&gt;Lambda Expressions&lt;/li&gt; &lt;li&gt;What are closures&lt;/li&gt; &lt;li&gt;Lambdas vs. Closures&lt;/li&gt; &lt;li&gt;Distinction by Examples&lt;/li&gt; &lt;li&gt;Close analog to a closure&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;just-your-everyday-functions&quot;&gt;Just your everyday functions&lt;/h3&gt; &lt;p&gt;When most people think of &lt;em&gt;functions&lt;/em&gt;, they think of &lt;strong&gt;named functions&lt;/strong&gt; such as -&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::string a_named_function () { return &quot;This string is returned from a named function&quot;; } // A named function &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;These are called by name, of course:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;foo(); //returns the string above &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;lambda-expressions&quot;&gt;Lambda Expressions&lt;/h3&gt; &lt;p&gt;The term “lambda” is short for &lt;em&gt;lambda expression&lt;/em&gt;, and a lambda is just that 😊:&lt;/p&gt; &lt;ol&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Lamdba expression&lt;/strong&gt; — An *expression *that specifies an anonymous function object.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;strong&gt;Lamdba function&lt;/strong&gt; — This term is used interchangeably with the term “lambda expression.”&lt;/p&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;As such, it exists only in a program’s source code.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;A lambda does not exist at runtime.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;A lambda expression &lt;strong&gt;specifies an object, not just a function without a name,&lt;/strong&gt; capable of capturing variables in scope.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Lambdas can frequently be passed around as objects.&lt;/li&gt; &lt;li&gt;A lambda is essentially a function object that is specified inline.&lt;/li&gt; &lt;li&gt;In addition to its own function parameters, a lambda expression can refer to local variables in the scope of its definition.&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-are-closures&quot;&gt;What are closures&lt;/h3&gt; &lt;p&gt;&lt;strong&gt;* What is C++ specific part here&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;A closure is a general concept in programming that originated from functional programming. When we talk about the closures in C++, they always come with lambda expressions. &lt;br /&gt; In any other language like Python, closure are unrelated to Lambdas&lt;/em&gt; 😊&lt;/p&gt; &lt;p&gt;A &lt;strong&gt;&lt;em&gt;closure&lt;/em&gt;&lt;/strong&gt; is any function that &lt;strong&gt;&lt;em&gt;closes over&lt;/em&gt;&lt;/strong&gt; the &lt;strong&gt;&lt;em&gt;environment&lt;/em&gt;&lt;/strong&gt; in which it was defined. This means that it can access variables not in its parameter list.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;what-is-a-closure-anyway-in-c&quot;&gt;What is a Closure anyway in C++?&lt;/h4&gt; &lt;p&gt;A value* defined (rather encapsulated) by lambda expression that consists of both the code as well as the values of the variables referred to in the code.&lt;br /&gt; (We will discuss this asterisk * further in this article)&lt;/p&gt; &lt;p&gt;So closure is an anonymous function object that is created automatically by the compiler as the result of a lambda expression. A closure stores those variables from the scope of the definition of the lambda expression that is used in the lambda expression.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The runtime effect of a lambda expression is the generation of an object. Such objects are known as &lt;em&gt;closures&lt;/em&gt;.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;A closure is a function that encloses its surrounding state by referencing fields external to its body. The enclosed state remains across invocations of the closure&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;lambdas-vs-closures&quot;&gt;Lambdas vs. Closures&lt;/h3&gt; &lt;p&gt;S&lt;strong&gt;cott Meyers&lt;/strong&gt; puts it beautifully — “&lt;strong&gt;The distinction between a lambda and the corresponding closure is precisely equivalent to the distinction between a class and an instance of the class&lt;/strong&gt;”.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Closures are to lambdas as objects are to classes.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;As we know, a class exists only in source code; it doesn’t exist at runtime. What exists at runtime are objects of the class type. Similarily -&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Each lambda expression causes a unique class to be generated (during compilation) and also causes an object of that class type–a closure–to be created (at runtime).&lt;/p&gt; &lt;/blockquote&gt; &lt;ol&gt; &lt;li&gt;Lambdas occupy no data memory at runtime, for example, though they may occupy code memory.&lt;/li&gt; &lt;li&gt;Closures occupy data memory, but not code memory.&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;distinction-by-examples&quot;&gt;Distinction by Examples&lt;/h3&gt; &lt;p&gt;Let’s take an example —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;auto f = [&amp;amp;](int x, int y) { return fudgeFactor * (x + y); }; // the expression to the right of the &quot;=&quot; is the lambda expression (i.e., &quot;the lambda&quot;), // The runtime object created by that expression is the closure. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;f&lt;/code&gt; itself is not a closure, it is a &lt;strong&gt;&lt;em&gt;copy of the closure&lt;/em&gt;&lt;/strong&gt; 🥴&lt;/p&gt; &lt;h4 id=&quot;ok-what-do-you-mean&quot;&gt;&lt;strong&gt;Ok, what do you mean?&lt;/strong&gt;&lt;/h4&gt; &lt;p&gt;The process of copying the closure into f may be optimized into a move but that doesn’t change the fact that f itself is not the closure.&lt;/p&gt; &lt;p&gt;The actual closure object is a temporary that’s typically destroyed at the end of the statement unless you bind it to a &lt;a href=&quot;https://medium.com/pranayaggarwal25/universal-reference-perfect-forwarding-5664514cacf9&quot;&gt;forwarding reference(a.ka. Universal reference)&lt;/a&gt; or lvalue-reference-to-&lt;code&gt;const&lt;/code&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//===============================================================// auto&amp;amp;&amp;amp; rrefToClosure = [&amp;amp;](int x, int y) { return fudgeFactor * (x + y); }; const auto&amp;amp; lrefToConstToClosure = [&amp;amp;](int x, int y) { return fudgeFactor * (x + y); }; //===============================================================// &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Let’s take another example —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;//===============================================================// std::function&amp;lt;void(void)&amp;gt; closureWrapper1() { int x = 10; return [&amp;amp;x](){ std::cout &amp;lt;&amp;lt; &quot;Value in the closure: &quot; &amp;lt;&amp;lt; x++ &amp;lt;&amp;lt; std::endl; }; } int main() { int x = 10; auto func0 = [&amp;amp;x](){x += 1; std::cout &amp;lt;&amp;lt; &quot;Value in the closure: &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;}; func0(); // Prints 11 std::function&amp;lt;void(void)&amp;gt; func1 = closureWrapper1(); func1(); // Prints garbage value + 1 =~ garbage value } //===============================================================// &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;func1&lt;/code&gt; is not closure Instead, it’s a &lt;code&gt;std::function&lt;/code&gt; wrapper object that wrapped a closure.&lt;/p&gt; &lt;p&gt;&lt;code&gt;func0&lt;/code&gt; is a copy of a closure created by the lambda expression written after it.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;close-analog-to-a-closure&quot;&gt;Close analog to a closure&lt;/h3&gt; &lt;p&gt;&lt;strong&gt;Function Object (Functor)&lt;/strong&gt; — Function object overload the operator(). It could capture the values by making a copy of the variables to its member variables. The shortcoming is that for each different function call, regardless of how simple it is, we would have to implement a new class, whereas implementing a lambda expression is faster.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;http://scottmeyers.blogspot.com/2013/05/lambdas-vs-closures.html&quot;&gt;http://scottmeyers.blogspot.com/2013/05/lambdas-vs-closures.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://leimao.github.io/blog/CPP-Closure/&quot;&gt;https://leimao.github.io/blog/CPP-Closure/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda&quot;&gt;https://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;p&gt;Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article.&lt;/p&gt; &lt;p&gt;Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/p&gt;</content><author><name>admin</name></author><category term="C++"/><summary type="html">What are closures vs how lambdas are different from closures?</summary></entry><entry><title type="html">Object construction order in case of virtual and/or multiple inheritance</title><link href="https://techmunching.com/object-construction-order-in-case-of-virtual-and-or-multiple-inheritance/" rel="alternate" type="text/html" title="Object construction order in case of virtual and/or multiple inheritance"/><published>2020-07-03T00:00:00+00:00</published><updated>2020-07-03T00:00:00+00:00</updated><id>https://techmunching.com/object-construction-order-in-case-of-virtual-and-or-multiple-inheritance</id><content type="html" xml:base="https://techmunching.com/object-construction-order-in-case-of-virtual-and-or-multiple-inheritance/">&lt;p&gt;How virtual vs. multiple inheritance affect class object construction order?&lt;/p&gt; &lt;!-- ![](/img/0*VtNlssb8zTqF0nY9.gif) --&gt; &lt;div class=&quot;vidWrapper&quot;&gt; &lt;video style=&quot;max-width:100%&quot; autoplay=&quot;&quot; muted=&quot;&quot; loop=&quot;&quot;&gt; &lt;source src=&quot;/img/0*VtNlssb8zTqF0nY9.mp4&quot; type=&quot;video/mp4&quot; /&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;I’ll try to keep this post short and simple 😊&lt;/p&gt; &lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;An example class having virtual and/or multiple inheritance&lt;/li&gt; &lt;li&gt;What are the rules for object construction order?&lt;/li&gt; &lt;li&gt;Understanding the object construction order rules&lt;/li&gt; &lt;li&gt;Let’s apply the rules, shall we?&lt;/li&gt; &lt;li&gt;Bonus Question&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;example-a-class-having-virtual-andor-multiple-inheritance&quot;&gt;Example: A class having virtual and/or multiple inheritance&lt;/h3&gt; &lt;p&gt;class X is declared here as inherited by D1, D2 which in turn are inherited by other class in a complex manner by other classes.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_9ZFGEBfTvwaafG1tsZR4QQ.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;This will be our complex example&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Here as we clearly see following can be established — &lt;br /&gt; 1) V1 inherited by B1&lt;br /&gt; 2) D1 inherited by V1&lt;br /&gt; 3) V2 inherited by B1 and B2&lt;br /&gt; 4) D2 inherited by B3 and V2&lt;br /&gt; 5) X inherited by D1 and D2&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-are-the-rules-for-object-construction-order&quot;&gt;What are the rules for object construction order?&lt;/h3&gt; &lt;p&gt;The following set of rules is applied recursively:-&lt;/p&gt; &lt;h4 id=&quot;1-first-comes-virtual&quot;&gt;1. First comes virtual&lt;/h4&gt; &lt;p&gt;First, the most derived class’s constructor calls the constructors of the virtual base class subobjects. The very first constructors to be executed are the virtual base classes anywhere in the hierarchy. &lt;br /&gt; Virtual base classes are initialized &lt;strong&gt;In depth-first, left-to-right order.&lt;/strong&gt;&lt;/p&gt; &lt;h4 id=&quot;2-then-comes-multiple-inheritance-&quot;&gt;2. Then comes multiple inheritance —&lt;/h4&gt; &lt;p&gt;After all virtual base class constructors are finished, the construction order is generally from base class to derived class. Direct base class subobjects are constructed &lt;strong&gt;in the order they are declared in the class definition&lt;/strong&gt;.&lt;/p&gt; &lt;h4 id=&quot;3-next-comes-class-members&quot;&gt;3. Next comes class members&lt;/h4&gt; &lt;p&gt;Next, (nonstatic) member subobjects are constructed, in the order, they were declared in the class definition.&lt;/p&gt; &lt;h4 id=&quot;4-finally-the-constructor-body&quot;&gt;4. Finally the constructor body&lt;/h4&gt; &lt;p&gt;In the last, the body of the constructor is executed.&lt;/p&gt; &lt;p&gt;Also, one point to be noted is that —&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Whether the inheritance is public, protected, or private doesn’t affect initialization order&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h3 id=&quot;understanding-the-object-construction-order-rules&quot;&gt;Understanding the object construction order rules&lt;/h3&gt; &lt;p&gt;The rules are easiest to understand if you imagine that the very first thing the compiler does in the derived class’s constructor is to make a hidden call to the constructors of its virtual base and then non-virtual base classes (hint: that’s the way many compilers actually do it).&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;It’s like a DFS where the order on a same level is driven by class definitionExample — class &lt;strong&gt;&lt;em&gt;D&lt;/em&gt;&lt;/strong&gt; inherits from both &lt;em&gt;** B1 **&lt;/em&gt; and &lt;em&gt;** B2 **&lt;/em&gt;,&lt;/p&gt; &lt;/blockquote&gt; &lt;ol&gt; &lt;li&gt;The constructor for &lt;em&gt;**B1 **&lt;/em&gt; executes first&lt;/li&gt; &lt;li&gt;then the constructor for &lt;strong&gt;&lt;em&gt;B2&lt;/em&gt;&lt;/strong&gt;,&lt;/li&gt; &lt;li&gt;Then the constructor for &lt;strong&gt;&lt;em&gt;D&lt;/em&gt;&lt;/strong&gt;. &lt;br /&gt; This rule is applied recursively For example, if &lt;strong&gt;&lt;em&gt;B1 **&lt;/em&gt; inherits from **&lt;em&gt;B1a&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;B1b&lt;/em&gt;&lt;/strong&gt;, and &lt;strong&gt;&lt;em&gt;B2&lt;/em&gt;&lt;/strong&gt; inherits from &lt;strong&gt;&lt;em&gt;B2a&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;B2b&lt;/em&gt;&lt;/strong&gt;,&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;then the final order is&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;&lt;em&gt;B1a&lt;/em&gt;&lt;/strong&gt; =&amp;gt; &lt;strong&gt;&lt;em&gt;B1b&lt;/em&gt;&lt;/strong&gt; =&amp;gt; &lt;em&gt;**B1 **&lt;/em&gt;, and then&lt;/li&gt; &lt;li&gt;&lt;strong&gt;&lt;em&gt;B2a =&amp;gt; B2b =&amp;gt;&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;B2&lt;/em&gt;&lt;/strong&gt;*&lt;/li&gt; &lt;li&gt;&lt;em&gt;and ofcourse in the end&lt;/em&gt; &lt;strong&gt;D&lt;/strong&gt;.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Note that the order &lt;strong&gt;&lt;em&gt;B1 **&lt;/em&gt; and then **&lt;em&gt;B2&lt;/em&gt;&lt;/strong&gt; (or &lt;strong&gt;&lt;em&gt;B1a&lt;/em&gt;&lt;/strong&gt; then &lt;strong&gt;&lt;em&gt;B1b&lt;/em&gt;&lt;/strong&gt;) is determined by the order that the base classes appear in the declaration of the class, &lt;em&gt;not&lt;/em&gt; in the order that the initializer appears in the derived class’s initialization list.&lt;/p&gt; &lt;p&gt;[ Refer &lt;a href=&quot;https://medium.com/pranayaggarwal25/using-modern-class-members-and-initializations-c11e931c3ba&quot;&gt;https://medium.com/pranayaggarwal25/using-modern-class-members-and-initializations-c11e931c3ba&lt;/a&gt; for more details about class member initializations ]&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;lets-apply-the-rules-shall-we&quot;&gt;Let’s apply the rules, shall we?&lt;/h3&gt; &lt;p&gt;&lt;img src=&quot;/img/1_9ZFGEBfTvwaafG1tsZR4QQ.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Looks easier now, doesn’t it?&lt;/em&gt;&lt;/p&gt; &lt;p&gt;The initialization order for a X object in Example 2 is as follows, where each constructor call shown represents the execution of the body of that constructor:&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_a-qxlGwcVWru5zB3Xo_4Yw.webp&quot; alt=&quot;&quot; /&gt;So —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_TTTVf62ztLB7o-Z0g3na2A.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;First — Construct the virtual bases V1 and V2 recursively by rules&lt;/em&gt; After that, construct the remaining nonvirtual bases:&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_TY1_6ucxEUqM8HNQgeMsgQ.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Second — Construct the remaining non-virtual bases D1 and D2&lt;/em&gt; Next, construct the members &lt;strong&gt;&lt;em&gt;M1 **&lt;/em&gt; and **&lt;em&gt;M2 —&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_cDhZbtSxlmIfZanCtUjkAA.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Third — Class member construction&lt;/em&gt; and in the last —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_d0jyqK1WZL9p4MfTVvnRlg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Final construction&lt;/em&gt;&lt;/p&gt; &lt;p&gt;if you’re a fan of graphics, here is how the inheritance hierarchy looks like :&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_lNJNK6S_PTgulnoservZoQ.webp&quot; alt=&quot;&quot; /&gt; &lt;em&gt;Inheritance and object construction hierarchy (v means Virtual)&lt;/em&gt;&lt;/p&gt; &lt;p&gt;That’s pretty much it!&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0*RymMjGO7qYGCJPV2&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;bonus-question-time-yay-&quot;&gt;Bonus Question Time, yay!! 😉&lt;/h3&gt; &lt;p&gt;Thanks for reading it till here.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-is-the-exact-order-of-destructors-in-a-multiple-andor-virtual-inheritance-situation&quot;&gt;What is the exact order of destructors in a multiple and/or virtual inheritance situation?&lt;/h3&gt; &lt;p&gt;The exact opposite of the same constructor order.&lt;/p&gt; &lt;p&gt;Reminder to make your base class’s destructor virtual, at least in the normal case. Why, I think you already know why? 😊&lt;/p&gt; &lt;p&gt;When someone says &lt;em&gt;delete&lt;/em&gt; using a &lt;em&gt;Base&lt;/em&gt; pointer that’s pointing at a &lt;em&gt;Derived&lt;/em&gt; object, had &lt;em&gt;Base&lt;/em&gt;’s destructor not been &lt;em&gt;virtual&lt;/em&gt;, &lt;em&gt;Derived&lt;/em&gt;’s destructor would not have been called – with likely bad effects, such as resources owned by Derived not being freed.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;http://www.gotw.ca/gotw/080.htm&quot;&gt;http://www.gotw.ca/gotw/080.htm&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://isocpp.org/wiki/faq/multiple-inheritance#mi-vi-ctor-order&quot;&gt;https://isocpp.org/wiki/faq/multiple-inheritance#mi-vi-ctor-order&lt;/a&gt; Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article.&lt;br /&gt; Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><category term="OOPS"/><summary type="html">How virtual vs. multiple inheritance affect class object construction order?</summary></entry><entry><title type="html">Using Modern C++ class members and initializations the right way</title><link href="https://techmunching.com/using-modern-c-class-members-and-initializations-the-right-way/" rel="alternate" type="text/html" title="Using Modern C++ class members and initializations the right way"/><published>2020-07-03T00:00:00+00:00</published><updated>2020-07-03T00:00:00+00:00</updated><id>https://techmunching.com/using-modern-c---class-members-and-initializations-the-right-way</id><content type="html" xml:base="https://techmunching.com/using-modern-c-class-members-and-initializations-the-right-way/">&lt;p&gt;Using In-member initialization, using constructors smartly and using class members functions in a safe and proper way to avoid mistakes&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0_csRd0YjayeNTl96F.webp&quot; alt=&quot;&quot; /&gt;Clean code!### Table of Contents&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Use member initializers in the same order as their declaration&lt;/li&gt; &lt;li&gt;Prefer in-class member initializer over constant initializations OR over default constructor.&lt;/li&gt; &lt;li&gt;Don’t cast away const, ever!&lt;/li&gt; &lt;li&gt;Use delegating constructors to represent common actions for all constructors of a class. &lt;h3 id=&quot;1-use-member-initializers-in-the-same-order-as-their-declaration&quot;&gt;1. Use member initializers in the same order as their declaration&lt;/h3&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Member variables are always initialized in the order they are declared in the class definition.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;The order in which you write them in the constructor initialization list is ignored 🥴&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Make sure the constructor code doesn’t confusingly specify different orders. For e.g. this case as below —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_Wzlu5I7J1KamJhQYob7_4w.webp&quot; alt=&quot;&quot; /&gt;Would lead to issuesemail is declared before first_name and last_name in the class definition, hence as per the constructor call, it will be initialized first and will attempt to use the other not-yet-initialized fields which are first_name and last_name .&lt;/p&gt; &lt;h4 id=&quot;how-to-make-it-right&quot;&gt;How to make it right&lt;/h4&gt; &lt;p&gt;This code harbors a bug that’s as subtly harmful as it is hard to spot hence&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Write member initializers in the same order as their declarationMany compilers (but not all) will issue a warning if you break this rule. Modern compilers Clang, MSVC detect it with the right use of right warning flags.&lt;/p&gt; &lt;/blockquote&gt; &lt;h4 id=&quot;reason&quot;&gt;Reason&lt;/h4&gt; &lt;p&gt;The reason for this language design decision is to ensure there is a unique order to destroy members; otherwise, the destructor would have to destroy objects in different orders, depending on the constructor that built the object.&lt;/p&gt; &lt;h4 id=&quot;benefit&quot;&gt;Benefit&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;Protects you from an oddity of the language without requiring everyone to know it.&lt;/li&gt; &lt;li&gt;Might encourage you to rethink your class design so this dependency goes away &lt;h3 id=&quot;2-prefer-in-class-member-initializer-over-constant-initializations-or-over-default-constructor&quot;&gt;2. Prefer in-class member initializer over constant initializations OR over default constructor&lt;/h3&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;You should don’t define a default constructor that only initializes data members; use in-class member initializers instead which works as a good fallback in case you forget to initialize something.&lt;/p&gt; &lt;p&gt;Example — A bad class that misses one initialization in a constructor&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_iRhyfPkavdlODmNqmNEKsw.webp&quot; alt=&quot;&quot; /&gt;&lt;strong&gt;Cons of not using in-member class initializers&lt;/strong&gt;where the following is an example of a much better class&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_GNGSOMx_9NcelulDaYnytg.webp&quot; alt=&quot;&quot; /&gt;&lt;strong&gt;Using in-member class initializers, Nice!!&lt;/strong&gt;#### Reason&lt;/p&gt; &lt;p&gt;Using in-class member initializers lets the compiler generate the function for you. Also, the compiler-generated function can be more efficient 😊&lt;/p&gt; &lt;h4 id=&quot;benefits&quot;&gt;Benefits&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;No overhead of taking care of initializing constants separately in each constructor.&lt;/li&gt; &lt;li&gt;Performance gain by using standard default constructors. &lt;h3 id=&quot;3-dont-cast-away-const-ever&quot;&gt;3. Don’t cast away const, ever!&lt;/h3&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;We shouldn’t cast away from getter functions even when there seems a need.&lt;/p&gt; &lt;p&gt;For e.g. — Stuff is a class that does some calculations overnumber1 and number2 and computes the result. Now getValue() const is a function that fetches the value, and being a getter function is marked const.&lt;/p&gt; &lt;p&gt;number1 and number2 are updated byService1() and Service2() functions respectively.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_AuUxrjVaYzHmo_OacXV5qA.webp&quot; alt=&quot;&quot; /&gt;Now, in case read frequency of getValue() is much more than the number of writes, we should preemptively update the cachedValue which is returned.&lt;/p&gt; &lt;p&gt;Such as —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_rqMbsx6k1igbaXt3OKW5dw.webp&quot; alt=&quot;&quot; /&gt;However, in case the number of writes is much more, we should follow &lt;strong&gt;a lazy calculation approach&lt;/strong&gt; where we set a dirty flag such as below —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_TD_ZSa_Y2-jmsOZHZO8B2w.webp&quot; alt=&quot;&quot; /&gt;getValue function would show error as it’s marked constBut this poses a problem because const function can not modify this **newly introduced class member variable **cachedValid .&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;A wrong fix **would be to remove const from&lt;/strong&gt; **getValue() function&lt;/li&gt; &lt;li&gt;&lt;em&gt;*Another wrong fix **would be to const_cast over “&lt;/em&gt;this”* pointer. &lt;h4 id=&quot;reason-1&quot;&gt;Reason&lt;/h4&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Doing this makes a lie out of const. Any variable is actually declared asconst, modifying it may result in undefined behavior.&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Allows getValue() function to change anything in the instance.&lt;/li&gt; &lt;li&gt;The header file is now speaking a lie basically. &lt;h4 id=&quot;correct-fix&quot;&gt;Correct Fix&lt;/h4&gt; &lt;/li&gt; &lt;/ol&gt; &lt;p&gt;The right fix would be to declare cachedValid and cachedValue as mutable so that thegetValue() function can only modify the mutable ones.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_DgxaGoDSuAcpP58716AYRQ.webp&quot; alt=&quot;&quot; /&gt;The correct fix#### Benefits of correct fix&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Header file tells the truth&lt;/li&gt; &lt;li&gt;getValue() function can only change the mutable variables&lt;/li&gt; &lt;li&gt;Code accessing mutable members is shorter and more readable&lt;/li&gt; &lt;li&gt;Easier to write, read, and maintain&lt;/li&gt; &lt;li&gt;Const-correctness may enable optimizations 😊 &lt;h3 id=&quot;4-use-delegating-constructors-to-represent-common-actions-for-all-constructors-of-a-class&quot;&gt;4. Use delegating constructors to represent common actions for all constructors of a class&lt;/h3&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;The common action gets tedious to write and may accidentally not be common. Hence, wherever possible we should refer to existing constructors.&lt;/p&gt; &lt;p&gt;For e.g. — This Date is a bad class.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_WNgLgmo1n2TEsdoGYPy_EQ.webp&quot; alt=&quot;&quot; /&gt;A bad series of constructors, duplicate logic&lt;img src=&quot;/img/1_B5w6vP4oil0rnbYdMWkyng.webp&quot; alt=&quot;&quot; /&gt;&lt;strong&gt;Good!! Using delegating constructors&lt;/strong&gt;#### Reason&lt;/p&gt; &lt;p&gt;To avoid repetition and accidental differences.&lt;/p&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=XkDEzfpdcSg&quot;&gt;https://www.youtube.com/watch?v=XkDEzfpdcSg&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586&quot;&gt;C++ Coding Standards: 101 Rules, Guidelines, and Best Practices by Herb Sutter, Andrei Alexandrescu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines&quot;&gt;https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines&lt;/a&gt; Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article.&lt;br /&gt; Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><summary type="html">Using In-member initialization, using constructors smartly and using class members functions in a safe and proper way to avoid mistakes</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/0_csRd0YjayeNTl96F.webp"/><media:content medium="image" url="https://techmunching.com/img/0_csRd0YjayeNTl96F.webp" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Passing smart pointers shared_ptr and unique_ptr</title><link href="https://techmunching.com/passing-smart-pointers-shared-ptr-and-unique-ptr/" rel="alternate" type="text/html" title="Passing smart pointers shared_ptr and unique_ptr"/><published>2020-06-17T00:00:00+00:00</published><updated>2020-06-17T00:00:00+00:00</updated><id>https://techmunching.com/passing-smart-pointers-shared-ptr-and-unique-ptr</id><content type="html" xml:base="https://techmunching.com/passing-smart-pointers-shared-ptr-and-unique-ptr/">&lt;p&gt;General guidelines to follow for passing shared_ptr and unique_ptr as function arguments and at the time of return.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0*MKKxnMeiF8CTX0zm&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;As always, prefer unique_ptr to shared_ptr, unless you intend to share ownership.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Always ask yourself “Do I really need to pass a smart pointer ?”&lt;/li&gt; &lt;li&gt;std::unique_ptr usage&lt;/li&gt; &lt;li&gt;std::shared_ptr usage&lt;/li&gt; &lt;li&gt;How to pass correctly pass raw pointer/reference?&lt;/li&gt; &lt;li&gt;For Returning smart pointers, what is the norm?&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;always-ask-yourself-do-i-really-need-to-pass-a-smart-pointer-&quot;&gt;Always ask yourself “Do I really need to pass a smart pointer ?”&lt;/h3&gt; &lt;p&gt;You should always assess if passing smart pointers as a function parameter is what you really need. In most cases, you just need to use it and be done with it. In those cases, it’s always good to get a raw pointer and pass it on.&lt;/p&gt; &lt;p&gt;Now before we go further, I must tell you that &lt;strong&gt;raw pointers aren’t always bad&lt;/strong&gt;. They can be quite useful in many cases as we’ll read in this post.&lt;/p&gt; &lt;hr /&gt; &lt;h4 id=&quot;guideline&quot;&gt;&lt;strong&gt;Guideline&lt;/strong&gt;&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;Don’t pass a smart pointer as a function parameter unless you want to use or manipulate it, such as to share or transfer ownership. &lt;strong&gt;Prefer&lt;/strong&gt; passing objects by non-owning raw pointers (*) OR references (&amp;amp;).&lt;/p&gt; &lt;/blockquote&gt; &lt;h4 id=&quot;reason-and-example&quot;&gt;Reason and Example&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void f( widget* ); void f( widget&amp;amp; ); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;They stay agnostic of whatever lifetime policy the caller use and are good to observe an object whose lifetime we know exceeds that of the pointer or reference.&lt;/p&gt; &lt;p&gt;This is restrictive and can’t beeasy to commit always then we’ll see and asset the best possible way to pass smart pointers.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_CiD2BpQ9eDI1PX9OYMMLAQ.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Step1: Know your lifetimes…The full picture would keep becoming more clear :)&lt;/em&gt;&lt;/p&gt; &lt;p&gt;So following should be the guideline if we are sure about the lifetime —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_tuRoK1HFOMg2xkZcSGyTIw.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Guideline to follow in case of no share or transfer of ownership and valid lifetime&lt;/em&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;stdunique_ptr-usage&quot;&gt;std::unique_ptr usage&lt;/h3&gt; &lt;p&gt;&lt;em&gt;By value unique_ptr&amp;lt; type &amp;gt;&lt;/em&gt; assumes ownership of a &lt;em&gt;widget&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt; This is the preferred way to express a consuming function, also known as a &lt;strong&gt;“sink”&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;Using &lt;em&gt;unique_ptr&lt;/em&gt; in this way in both documents and code, enforces well the function call’s ownership transfer (&lt;em&gt;Expresses a “sink” function)&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Such as —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void sink(unique_ptr&amp;lt;widget&amp;gt;); // takes ownership of the widget // whereas void uses(widget*); // just uses the pointed object &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And a bad example is below —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void thinko(const unique_ptr&amp;lt;widget&amp;gt;&amp;amp;); // usually not what you want! &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;a href=&quot;/img/1_hsARhJ6S3gqAHfiNkdIlGQ.webp&quot;&gt;&lt;/a&gt;&lt;em&gt;unique_ptr passing guidelines&lt;/em&gt;&lt;/p&gt; &lt;p&gt;and our guideline picture is now —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_cp9haQg73JXSEN-xfrJB-g.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Step2: Know your transfers … More clear picture :)&lt;/em&gt;&lt;/p&gt; &lt;h4 id=&quot;guideline-1&quot;&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/h4&gt; &lt;blockquote&gt; &lt;p&gt;Express a “sink” function using a by-value &lt;em&gt;unique_ptr&lt;/em&gt; parameter. Use a non-const &lt;em&gt;unique_ptr&amp;amp;&lt;/em&gt; parameter only to modify the &lt;em&gt;unique_ptr&lt;/em&gt;.&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id=&quot;stdshared_ptr-usage&quot;&gt;std::shared_ptr usage&lt;/h3&gt; &lt;h4 id=&quot;passing-shared_ptr-by-value-only-when-you-are-sharing-the-ownership&quot;&gt;Passing shared_ptr by value only when you are sharing the ownership&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void f( shared_ptr&amp;lt;widget&amp;gt; ); // only when you want to retain // object and share ownership &lt;/code&gt;&lt;/pre&gt; &lt;blockquote&gt; &lt;p&gt;Sharing ownership comes with a cost, so make sure you really mean and intend to pay that price.In pass by value, the argument is copied (usually unless temporary) on entry to the function, and then destroy it (always) on function exit.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;Passing &lt;em&gt;shared_ptr&lt;/em&gt; by value means — &lt;br /&gt; 1) A new &lt;strong&gt;&lt;em&gt;shared_ptr&lt;/em&gt;&lt;/strong&gt; will be &lt;strong&gt;copy constructed.&lt;/strong&gt;&lt;br /&gt; 2) Ref count which is an atomic shared variable gets increased.&lt;br /&gt; 3) &lt;strong&gt;&lt;em&gt;shared_ptr&lt;/em&gt;&lt;/strong&gt; copy gets destroyed at the end of the function.&lt;br /&gt; 4) Ref count which is an atomic shared variable gets decreased.&lt;/p&gt; &lt;p&gt;[ Related post: &lt;a href=&quot;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&quot;&gt;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&lt;/a&gt; ]&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void f( const shared_ptr&amp;amp;&amp;lt;widget&amp;gt; ); // may share ownership void f( shared_ptr&amp;amp;&amp;lt;widget&amp;gt; ); // may reset pointerIn the special case where the function *might* share ownership but doesn’t necessarily take a copy of its parameter on a given call, then pass a const-ref to avoid the copy on the calls that don’t need it. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;So for &lt;strong&gt;&lt;em&gt;shared_ptr&lt;/em&gt;&lt;/strong&gt; follow this —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_1VklHsi0KmZw17S5o0VW8Q.webp&quot; alt=&quot;&quot; /&gt; &lt;em&gt;shared_ptr passing guidelines&lt;/em&gt; And finally, we have our full guideline picture here —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_GZhPV6_u-926_gDzo-_RHg.webp&quot; alt=&quot;&quot; /&gt; &lt;em&gt;Step3: The final guideline picture&lt;/em&gt;&lt;/p&gt; &lt;h3 id=&quot;how-to-pass-correctly-pass-raw-pointerreference&quot;&gt;How to pass correctly pass raw pointer/reference?&lt;/h3&gt; &lt;p&gt;As we have seen above that functions should prefer to pass raw pointers and references down call chains wherever possible.&lt;/p&gt; &lt;p&gt;At the top of the call tree where you obtain the raw pointer or reference from a smart pointer that keeps the object alive. You need to be sure that the smart pointer cannot inadvertently be reset or reassigned from within the call tree below.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;To do this, sometimes you need to take a local copy of a smart pointer, which firmly keeps the object alive for the duration of the function and the call tree.&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Consider this code, the following should not pass code review:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; // global (static or heap), or aliased local ... shared_ptr&amp;lt;widget&amp;gt; g_p = ...; void my_code() { // BAD: passing pointer or reference obtained from a non-local // smart pointer that could be inadvertently reset somewhere // inside f or its callees f(*g_p); // BAD: same reason, just passing it as a &quot;this&quot; pointer g_p-&amp;gt;func(); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The fix is simple — take a local copy of the pointer to keep a ref count for your call tree:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// global (static or heap), or aliased local ... shared_ptr&amp;lt;widget&amp;gt; g_p = ...; void my_code() { // **cheap:** 1 increment covers this entire function and call trees auto pin = g_p; // **GOOD:** passing pointer or reference obtained from a local // unaliased smart pointer f(*pin); // **GOOD:** same reason pin-&amp;gt;func(); } &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;for-returning-smart-pointers-what-is-the-norm&quot;&gt;For Returning smart pointers, what is the norm?&lt;/h3&gt; &lt;p&gt;You should follow the same logic above:&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Return smart pointers if the caller wants to manipulate the smart pointer itself, return raw pointers/references if the caller just needs a handle to the underlying object.If you really need to return smart pointers from a function, take it easy and always return &lt;em&gt;by value&lt;/em&gt;. That is:&lt;/p&gt; &lt;/blockquote&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::unique_ptr&amp;lt;Object&amp;gt; getUnique(); std::shared_ptr&amp;lt;Object&amp;gt; getShared(); std::weak_ptr&amp;lt;Object&amp;gt; getWeak(); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;There are at least three good reasons for this:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Move Semantics&lt;/strong&gt; &lt;strong&gt;—&lt;/strong&gt; Smart pointers are powered by move semantics: the dynamically-allocated resource they hold is moved around, not wastefully copied.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Return Value Optimization (RVO)&lt;/strong&gt; &lt;strong&gt;—&lt;/strong&gt;All modern compilers are able to detect that you are returning an object by value, and they apply a sort of return shortcut to avoid useless copies. Starting from C++17, this is guaranteed by the standard. Returning by reference inhibits that shortcut.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Object deletion probability —&lt;/strong&gt; Returning &lt;em&gt;std::shared_ptr&lt;/em&gt; by reference doesn’t properly increment the reference count, which opens up the risk of deleting something at the wrong time, by incurring the risk of having the object deleted (that may be local) when it goes out of scope in another context. Thanks to RVO. you don’t need to move anything when returning a &lt;em&gt;std::unique_ptr&lt;/em&gt; also.&lt;/li&gt; &lt;/ol&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; std::unique_ptr&amp;lt;Object&amp;gt; getUnique() { std::unique_ptr&amp;lt;Object&amp;gt; p = std::make_unique&amp;lt;Object&amp;gt;(); return p; // also return std::make_unique&amp;lt;Object&amp;gt;(); } &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/&quot;&gt;https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam&quot;&gt;http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-uniqueptrparam&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c&quot;&gt;https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c&lt;/a&gt; Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article.&lt;br /&gt; Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><summary type="html">General guidelines to follow for passing shared_ptr and unique_ptr as function arguments and at the time of return.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/0*MKKxnMeiF8CTX0zm"/><media:content medium="image" url="https://techmunching.com/img/0*MKKxnMeiF8CTX0zm" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Few Modern C++ Puzzles</title><link href="https://techmunching.com/few-modern-c-puzzles/" rel="alternate" type="text/html" title="Few Modern C++ Puzzles"/><published>2020-06-15T00:00:00+00:00</published><updated>2020-06-15T00:00:00+00:00</updated><id>https://techmunching.com/few-modern-c---puzzles</id><content type="html" xml:base="https://techmunching.com/few-modern-c-puzzles/">&lt;p&gt;Some puzzles from various talks, blog posts, and other bits&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0_3StcFi7Mii7eFJOZ.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Puzzle 1: Capturing unique_ptr by reference&lt;/li&gt; &lt;li&gt;Puzzle 2: Capturing the temporary by the reference&lt;/li&gt; &lt;li&gt;Puzzle 3: Making mistakes with std functions usage&lt;/li&gt; &lt;li&gt;Puzzle 4: Throwing away the dead&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;puzzle-1-capturing-unique_ptr-by-reference&quot;&gt;Puzzle 1: Capturing unique_ptr by reference&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;unique_ptr&amp;lt;A&amp;gt; myFun() { unique_ptr&amp;lt;A&amp;gt; pa(new A()); return pa; } const A&amp;amp; rA = *myFun(); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This code compiles but &lt;code&gt;rA&lt;/code&gt; contains garbage. Why is this code invalid?&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; if we assign the return of &lt;code&gt;myFun&lt;/code&gt; to a named &lt;code&gt;unique_ptr&lt;/code&gt; variable before dereferencing it, it works fine.&lt;/p&gt; &lt;h4 id=&quot;answer&quot;&gt;&lt;strong&gt;Answer:&lt;/strong&gt;&lt;/h4&gt; &lt;p&gt;The &lt;code&gt;unique_ptr&lt;/code&gt; will pass the ownership to another &lt;code&gt;unique_ptr&lt;/code&gt;, but in this code, there is nothing to capture the ownership from the returning pointer. In other words, It can not transfer the ownership, so it will be destructed. The proper way is:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;unique_ptr&amp;lt;A&amp;gt; rA = myFun(); // Pass the ownership &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;or&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;const A rA = *myFun(); // Store the values before destruction &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In this code, the returning pointer will be destructed and the reference is referring to an object which is destructing soon after that using this reference invokes undefined behavior.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;puzzle-2-capturing-the-temporary-by-the-reference&quot;&gt;Puzzle 2: Capturing the temporary by the reference&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;vector&amp;lt;bool&amp;gt; vb{true, true, false, true}; auto proxy = vb[0]; std::cout &amp;lt;&amp;lt; proxy // ok, Prints true vb.reserve(100); // A: ??? std::cout &amp;lt;&amp;lt; proxy // Error!! likely to print false on clang, why? &lt;/code&gt;&lt;/pre&gt; &lt;h4 id=&quot;answer-1&quot;&gt;Answer:&lt;/h4&gt; &lt;p&gt;Line A invalidates proxy so &lt;code&gt;proxy&lt;/code&gt; was invalidated by &lt;code&gt;vb.reserve&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Take below example —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;void example_1_1_3() { string_view s; // s points to null string name = &quot;abcdefghijklmnop&quot;; s = name; // A: s points to {name'} i.e. data owned by name’ cout &amp;lt;&amp;lt; s[0]; // B: ok – s[0] is ok because {a} is alive name = &quot;frobozz&quot;; // C: name modified =&amp;gt; name’ is invalid cout &amp;lt;&amp;lt; s[0]; // D: error – because it contains {invalid} } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;which is why guideline says –&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Never use the reference in case of a temporary argument.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;Take below example —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;char&amp;amp; c = std::string{&quot;hello my pretty long string&quot;}[0]; cout &amp;lt;&amp;lt; c; // (X) wrong to initialize a // reference ‘c’ with an invalid pointer, pointer // was invalidated with temporary string was // destroyed. &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;puzzle-3-making-mistakes-with-std-functions-usage&quot;&gt;Puzzle 3: Making mistakes with std functions usage&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int main() { auto x=10, y=2; auto&amp;amp; good = min(x,y); // ok, {x,y} cout &amp;lt;&amp;lt; good; // ok, fine. auto&amp;amp; bad = min(x,y+1) cout &amp;lt;&amp;lt; bad; // ERROR, why?? } &lt;/code&gt;&lt;/pre&gt; &lt;h4 id=&quot;answer-2&quot;&gt;Answer:&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int main() { auto x=10, y=2; auto&amp;amp; good = min(x,y); // ok, {x,y} cout &amp;lt;&amp;lt; good; // ok, fine. auto&amp;amp; bad = min(x,y+1) // A: IN: {x, temp(y+1)} // OUT: temp2 obtained by {x,temp} // min() returns temp2 // temp destroyed hence → temp2 = {invalid} cout &amp;lt;&amp;lt; bad; // ERROR, bad initialized as invalid now } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;In normal C++, this code compiles but has &lt;strong&gt;undefined behavior&lt;/strong&gt;.&lt;br /&gt; Note In practice, on the three major compilers (GCC, VC++, clang) this code does not crash and appears to work. That’s because one manifestation of “undefined behavior” can be “&lt;em&gt;happens to do what you expect.&lt;/em&gt;”&lt;/p&gt; &lt;p&gt;Nevertheless, this is undefined so one should be careful.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;puzzle-4-throwing-away-the-dead&quot;&gt;Puzzle 4: Throwing away the dead&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// godbolt.org/z/p_QjCR static int gi = 0; void f() { int i = 0; throw &amp;amp;i; // ERROR, why?? throw &amp;amp;gi; // OK } &lt;/code&gt;&lt;/pre&gt; &lt;h4 id=&quot;answer-3&quot;&gt;Answer:&lt;/h4&gt; &lt;p&gt;Unlike a return, the type of a thrown object cannot be carried through function signatures. Therefore, do not throw a Pointer with a lifetime other than static.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/30858850/dereferencing-a-temporary-unique-ptr&quot;&gt;https://stackoverflow.com/questions/30858850/dereferencing-a-temporary-unique-ptr&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1179r0.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1179r0.pdf&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><category term="C++20"/><summary type="html">Some puzzles from various talks, blog posts, and other bits</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/0_3StcFi7Mii7eFJOZ.webp"/><media:content medium="image" url="https://techmunching.com/img/0_3StcFi7Mii7eFJOZ.webp" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Coroutines and their introduction in C++</title><link href="https://techmunching.com/coroutines-and-their-introduction-in-c/" rel="alternate" type="text/html" title="Coroutines and their introduction in C++"/><published>2020-05-30T00:00:00+00:00</published><updated>2020-05-30T00:00:00+00:00</updated><id>https://techmunching.com/coroutines-and-their-introduction-in-c</id><content type="html" xml:base="https://techmunching.com/coroutines-and-their-introduction-in-c/">&lt;p&gt;Let’s discuss what coroutines are in general and how C++20 is introducing them&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0_qg0kAy5Zjb9DiXaU.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Prerequisite Terminology&lt;/li&gt; &lt;li&gt;What are coroutines?&lt;/li&gt; &lt;li&gt;Coroutines vs Subroutines?&lt;/li&gt; &lt;li&gt;Coroutines vs Threads&lt;/li&gt; &lt;li&gt;Applications of coroutines&lt;/li&gt; &lt;li&gt;Example in Python&lt;/li&gt; &lt;li&gt;How to simulate coroutines in traditional C++&lt;/li&gt; &lt;li&gt;Coroutines in C++20&lt;/li&gt; &lt;li&gt;Restrictions&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;prerequisite-terminology&quot;&gt;Prerequisite Terminology&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Cooperative Multitasking (a.k.a non-preemptive multitasking)&lt;/strong&gt; — If multitasking participant process or thread voluntarily let go of control periodically or when idle or logically blocked. This type of multitasking is called &lt;em&gt;“cooperative”&lt;/em&gt; because all programs must cooperate for the entire scheduling scheme to work.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Subroutine&lt;/strong&gt; — Any regular function that you write is a subroutine.&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-are-coroutines&quot;&gt;What are Coroutines?&lt;/h3&gt; &lt;p&gt;&lt;strong&gt;Coroutines&lt;/strong&gt; are stackless functions designed for enabling co-operative Multitasking, by allowing execution to be suspended and resumed.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Coroutines&lt;/strong&gt; suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. This allows for sequential code that executes asynchronously (e.g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses.&lt;/p&gt; &lt;p&gt;This is why coroutines are well-suited for implementing familiar program components such as cooperative tasks, exceptions, event loops, state machines, and pipes.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;coroutines-vs-subroutines&quot;&gt;Coroutines vs Subroutines?&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;With subroutines, execution begins at the start and finished on exit.&lt;/li&gt; &lt;li&gt;Subroutines are special cases of coroutines. Any subroutine can be translated to a coroutine which does not call ‘yield’ (relinquish control).&lt;/li&gt; &lt;li&gt; &lt;p&gt;Subroutines only return once and don’t hold the complete state between invocations. &lt;img src=&quot;/img/0_u8LQUT-o3R32MBgP.webp&quot; alt=&quot;&quot; /&gt;In contrast —&lt;/p&gt; &lt;/li&gt; &lt;li&gt;Coroutines can exit by calling other coroutines, which may later return to the point where they were invoked in the original coroutine; from the coroutine’s point of view, it is actually not exiting but calling another coroutine.&lt;/li&gt; &lt;li&gt;A coroutine instance holds state and varies between invocations. &lt;img src=&quot;/img/1_bYDtHHWQDCvDt3XZAkNVoQ.webp&quot; alt=&quot;&quot; /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;h3 id=&quot;coroutines-vs-threads&quot;&gt;Coroutines vs Threads&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Coroutines are designed to be performing as lightweight threads.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Coroutines provide concurrency but not parallelism [Important!]&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;Switching between coroutines need not involve any system/blocking calls so no need for synchronization primitives such as mutexes, semaphores.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Thus coroutines —&lt;/p&gt; &lt;ol&gt; &lt;li&gt;provide asynchronicity and resource locking isn’t needed.&lt;/li&gt; &lt;li&gt;are useful in functional programming techniques.&lt;/li&gt; &lt;li&gt;increase locality of reference.&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;applications-of-coroutines&quot;&gt;Applications of Coroutines&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Actor Model&lt;/strong&gt;: They are very useful to implement the actor model of concurrency. Each actor has its own procedures, but they give up control to the central scheduler, which executes them sequentially.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Generators&lt;/strong&gt;: It is useful to implement generators that are targeted for streams particularly input/output and for traversal of data structures.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Reverse Communication&lt;/strong&gt;: They are useful to implement reverse communication which is commonly used in mathematical software, wherein a procedure needs the using process to make a computation.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;&lt;strong&gt;Example 1—&lt;/strong&gt;To read a file and parse it while finding (matching) some meaningful data, you can either read step by step at each line, which is fine. You may also load the entire content in memory, which won’t be recommended for large text.&lt;/p&gt; &lt;p&gt;Coroutines are there to throw away the stack concept completely. Stop thinking of one process as the caller and the other as the callee, and start thinking of them as &lt;strong&gt;cooperating equals&lt;/strong&gt;.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0*DaO1S9QPlS2HOrhA&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Execution flow for reading a file and finding text&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Example 2 —&lt;/strong&gt;You have a consumer-producer relationship where one routine creates items and adds them to a queue and another removes items from the queue and uses them. For reasons of efficiency, you want to add and remove several items at once. The pseudo-code might look like this:&lt;/p&gt; &lt;pre&gt; &lt;code&gt; &lt;i&gt;var&lt;/i&gt; q := new queue &lt;b&gt;coroutine&lt;/b&gt; produce &lt;b&gt;loop&lt;/b&gt; &lt;b&gt;while&lt;/b&gt; q is not full create some new items add the items to q &lt;b&gt;yield&lt;/b&gt; to consume &lt;b&gt;coroutine&lt;/b&gt; consume &lt;b&gt;loop&lt;/b&gt; &lt;b&gt;while&lt;/b&gt; q is not empty remove some items from q use the items &lt;b&gt;yield&lt;/b&gt; to produce &lt;/code&gt; &lt;/pre&gt; &lt;p&gt;The queue is then completely filled or emptied before yielding control to the other coroutine using the &lt;em&gt;yield&lt;/em&gt; command.&lt;/p&gt; &lt;p&gt;(This example is often used as an introduction to multithreading, two threads are not a must need for this).&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;an-example-in-python&quot;&gt;An example in Python&lt;/h3&gt; &lt;p&gt;If you have used Python, you may know that there is a keyword called yield that allows loop back and forth between the caller and the called function until the caller is not done with function or the function terminates because of some logic it is given.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt; # A Python program to generate numbers in a range using yield def rangeN(a, b): i = a while (i &amp;lt; b): yield i i += 1 # Next execution resumes from this point for i in rangeN(1, 5): print(i) &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;how-to-simulate-coroutines-in-traditional-c&quot;&gt;How to simulate coroutines in traditional C++&lt;/h3&gt; &lt;p&gt;To simulate coroutines in traditional C++ is challenging as for every response to a function call, there is a stack being initialized that keeps track of all its variables and constants and gets destroyed when the function call ends.&lt;/p&gt; &lt;p&gt;For the same range example, to simulate a simple switch coroutine suspend-resume we can do something like —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// A bad simulation of coroutine, no state saving #include&amp;lt;iostream&amp;gt; int range(int a, int b) { static long long int i = a-1; for (;i &amp;lt; b;) { return ++i; } return 0; } int main() { int i; for (; i=range(1, 5);) std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; '\n'; return 0; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;However, this doesn’t hold good for coroutines criteria of saving/resuming from the saved state :(&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// A better simulation of coroutine, state saving!! #include&amp;lt;iostream&amp;gt;int range(int a, int b) { static long long int i; static int state = 0; switch (state) { case 0: /* start of function */ state = 1; for (i = a; i &amp;lt; b; i++) { return i; /* Returns control */ case 1: ; /* resume control straight after the return */ } } state = 0; return 0; } int main() { int i; for (; i = range(1, 5);) std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; '\n'; return 0; } &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;coroutines-in-c20&quot;&gt;Coroutines in C++20&lt;/h3&gt; &lt;p&gt;In c++20, coroutines are coming. A function is a coroutine if its definition does any of the following:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;uses the &lt;em&gt;co_await&lt;/em&gt; operator to suspend execution until resumed.&lt;/li&gt; &lt;li&gt;uses the keyword &lt;em&gt;co_yield&lt;/em&gt; to suspend execution returning a value.&lt;/li&gt; &lt;li&gt;uses the keyword &lt;em&gt;co_return&lt;/em&gt; to complete execution. Let’s take a similar example to get a range.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For the simplicity of this post, let’s assume a generator template is something that exists already and can be used to generate a range,&lt;/p&gt; &lt;p&gt;(This blog post from Microsoft &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/october/c-from-algorithms-to-coroutines-in-c&quot;&gt;&lt;em&gt;https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/october/c-from-algorithms-to-coroutines-in-c&lt;/em&gt;&lt;/a&gt; is amazing regarding the generator pattern details)&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; // Coroutine gets called on need generator &amp;lt;int&amp;gt; generateNumbers(int begin, int inc = 1) { for (int i = begin;; i += inc) { co_yield i; } } int main() { std::cout &amp;lt;&amp;lt; std::endl; const auto numbers = generateNumbers(-10); for (int i = 1; i&amp;lt;= 20; ++i) std::cout &amp;lt;&amp;lt; numbers &amp;lt;&amp;lt; &quot; &quot;; // Runs finite = 20 times*** for (auto n:generateNumbers(0, 5)) // Runs infinite times** std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot; &quot;; // (3) std::cout &amp;lt;&amp;lt; &quot;\n\n&quot;; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;We’ll cover more about coroutines later as it gets better documented and evolved.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;restrictions&quot;&gt;Restrictions&lt;/h3&gt; &lt;p&gt;Every coroutine in C++ has some restrictions noted below. So coroutines —&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Can’t return&lt;/strong&gt; with &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/variadic_arguments&quot; title=&quot;cpp/language/variadic arguments&quot;&gt;variadic arguments&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Can’t return&lt;/strong&gt; using plain &lt;em&gt;return&lt;/em&gt;&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Can’t return&lt;/strong&gt; &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/function&quot; title=&quot;cpp/language/function&quot;&gt;placeholder&lt;/a&gt; (&lt;em&gt;auto&lt;/em&gt; or &lt;em&gt;Concept&lt;/em&gt;)&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Can’t be&lt;/strong&gt; &lt;em&gt;constexpr&lt;/em&gt; functions.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Can’t be&lt;/strong&gt; constructors or destructors.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Can’t be&lt;/strong&gt; the main function.&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h4 id=&quot;references&quot;&gt;References&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/coroutines&quot;&gt;https://en.cppreference.com/w/cpp/language/coroutines&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.xenonstack.com/insights/coroutines/&quot;&gt;https://www.xenonstack.com/insights/coroutines/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/48106252/why-threads-are-showing-better-performance-than-coroutines&quot;&gt;https://stackoverflow.com/questions/48106252/why-threads-are-showing-better-performance-than-coroutines&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.modernescpp.com/index.php/c-20-coroutines-the-first-overview&quot;&gt;https://www.modernescpp.com/index.php/c-20-coroutines-the-first-overview&lt;/a&gt; Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve!!&lt;br /&gt; Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><category term="C++20"/><category term="featured"/><summary type="html">Let’s discuss what coroutines are in general and how C++20 is introducing them</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/0_qg0kAy5Zjb9DiXaU.webp"/><media:content medium="image" url="https://techmunching.com/img/0_qg0kAy5Zjb9DiXaU.webp" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Using custom deleters with shared_ptr and unique_ptr in C++</title><link href="https://techmunching.com/using-custom-deleters-with-shared-ptr-and-unique-ptr-in-c/" rel="alternate" type="text/html" title="Using custom deleters with shared_ptr and unique_ptr in C++"/><published>2020-05-29T00:00:00+00:00</published><updated>2020-05-29T00:00:00+00:00</updated><id>https://techmunching.com/using-custom-deleters-with-shared-ptr-and-unique-ptr-in-c</id><content type="html" xml:base="https://techmunching.com/using-custom-deleters-with-shared-ptr-and-unique-ptr-in-c/">&lt;p&gt;How to use a custom deleter with an &lt;em&gt;unique_ptr&lt;/em&gt; and &lt;em&gt;shared_ptr&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/0*doMK1rnrcwhJmTks&quot; alt=&quot;&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Related post:&lt;/strong&gt; &lt;a href=&quot;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&quot;&gt;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&lt;/a&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;Introduction&lt;/li&gt; &lt;li&gt;The true unknown face of smart pointers&lt;/li&gt; &lt;li&gt;What is &lt;em&gt;std::default_delete&lt;/em&gt; indeed?&lt;/li&gt; &lt;li&gt;Ways to specify custom deleters&lt;/li&gt; &lt;li&gt;Using custom deleter with &lt;em&gt;shared_ptr&lt;/em&gt;&lt;/li&gt; &lt;li&gt;Using custom deleter with &lt;em&gt;unique_ptr&lt;/em&gt;&lt;/li&gt; &lt;li&gt;Storage of custom deleters&lt;/li&gt; &lt;li&gt;Restrictions that come with custom deleters&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt; &lt;p&gt;Why and when would we need something like that?&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 1:&lt;/strong&gt; In order to fully delete an object sometimes, we need to do some additional action. What if performing “delete” (that smart pointers do automatically)is not the only thing which needs to be done before fully destroying the owned object.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 2:&lt;/strong&gt; We can’t bind a shared_ptr or unique_ptr to a stack-allocated object, because calling delete on it would cause undefined behaviour.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 3:&lt;/strong&gt; Mix of programming languages code, such as C++ with Obj-C++. As objective-c may need a complex release mechanism for its data types such as calling &lt;a href=&quot;https://developer.apple.com/documentation/corefoundation/1521153-cfrelease&quot;&gt;CFRelease&lt;/a&gt;, we would be in need of a custom deleter.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 4:&lt;/strong&gt; In C where, when you wrap &lt;code&gt;FILE*&lt;/code&gt;, or some kind of a C style structure &lt;code&gt;free()&lt;/code&gt;, custom deleters may be useful.&lt;/p&gt; &lt;p&gt;and a few other cases.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;the-true-unknown-face-of-smart-pointers&quot;&gt;The true unknown face of &lt;em&gt;smart pointers&lt;/em&gt;&lt;/h3&gt; &lt;h4 id=&quot;stdunique_ptr&quot;&gt;std::unique_ptr&lt;/h4&gt; &lt;p&gt;The complete type of &lt;strong&gt;&lt;em&gt;std::unique_ptr&lt;/em&gt;&lt;/strong&gt; has a second template parameter, its deleter that has a default type &lt;code&gt;std::default_delete&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;br /&gt; What is that?? No need to worry, We’ll cover this together :)&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt; class T, class Deleter = std::default_delete&amp;lt;T&amp;gt;&amp;gt; class unique_ptr; // Manages a single object template &amp;lt; class T, class Deleter&amp;gt; class unique_ptr&amp;lt;T[], Deleter&amp;gt;; // Manages a dynamically-allocated array of objects &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;std::default_delete&amp;lt;T&amp;gt;&lt;/code&gt; is a &lt;strong&gt;function object&lt;/strong&gt; (a.k.a &lt;code&gt;functor&lt;/code&gt;) that calls delete on the object when invoked. This is only the default type for invoking &lt;em&gt;Deleter&lt;/em&gt; and it can be replaced with a custom deleter.&lt;/p&gt; &lt;p&gt;The invocation is done using operator() on the &lt;em&gt;Deleter&lt;/em&gt;.&lt;/p&gt; &lt;h4 id=&quot;stdshared_ptr&quot;&gt;std::shared_ptr&lt;/h4&gt; &lt;p&gt;You can pass any callable thing (lambda, functor) as deleter while constructing a shared pointer in the constructor as an additional argument.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt; class Y, class Deleter &amp;gt; shared_ptr( Y* ptr, Deleter d ); // One of the overloads of shared_ptr construction &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;thus specifying custom deleter with std::shared_ptr is comparatively easy.&lt;/p&gt; &lt;p&gt;On ref count reaches zero, the shared_ptr uses the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/delete&quot; title=&quot;cpp/language/delete&quot;&gt;delete-expression&lt;/a&gt; i.e. delete ptr.&lt;/p&gt; &lt;p&gt;Also since C++17 —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// shared_ptr can be used to manage a dynamically allocated array // since C++17 by specifying template argument with T[N] or T[]. So // you may write shared_ptr&amp;lt;int[]&amp;gt; myShared(new int[10]); &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-is-stddefault_delete-indeed&quot;&gt;What is std::default_delete indeed?&lt;/h3&gt; &lt;p&gt;This is defined in &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; header.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt; class T &amp;gt; struct default_delete; template&amp;lt; class T &amp;gt; struct default_delete&amp;lt;T[]&amp;gt;; &lt;/code&gt;&lt;/pre&gt; &lt;ol&gt; &lt;li&gt;The non-specialized &lt;em&gt;default_delete&lt;/em&gt; uses &lt;strong&gt;&lt;em&gt;delete&lt;/em&gt;&lt;/strong&gt; to deallocate memory for a single object.&lt;/li&gt; &lt;li&gt;A partial specialization for array types that uses &lt;strong&gt;&lt;em&gt;delete[]&lt;/em&gt;&lt;/strong&gt; is also provided.&lt;/li&gt; &lt;/ol&gt; &lt;h4 id=&quot;members&quot;&gt;Members:&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Constructor —&lt;/strong&gt; can be default or templated.&lt;/li&gt; &lt;/ol&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;constexpr default_delete() noexcept = default; // default template &amp;lt;class U&amp;gt; default_delete( const default_delete&amp;lt;U&amp;gt;&amp;amp; d ) noexcept; // templated // Constructs a std::default_delete object from another. // Overload resolution if U* is implicitly convertible to T*. &lt;/code&gt;&lt;/pre&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;operator() —&lt;/strong&gt; overload for the operator() is needed for the callability of struct/class as its a function object( or functor).&lt;br /&gt; At the point in the code where, this operator() is called, the type must be complete and defined.&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Examples:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;Example 1: { std::unique_ptr&amp;lt;int&amp;gt; ptr(new int(5)); } // unique_ptr&amp;lt;int&amp;gt; uses default_delete&amp;lt;int&amp;gt; ==================================================================== Example 2: { std::unique_ptr&amp;lt;int[]&amp;gt; ptr(new int[10]); } // unique_ptr&amp;lt;int[]&amp;gt; uses default_delete&amp;lt;int[]&amp;gt; ==================================================================== Example 3: // default_delete can be used anywhere a delete functor is needed std::vector&amp;lt;int*&amp;gt; v; for(int n = 0; n &amp;lt; 100; ++n) v.push_back(new int(n)); std::for_each(v.begin(), v.end(), std::default_delete&amp;lt;int&amp;gt;()); // Constructing the function object to be called ==================================================================== Example 4: { std::shared_ptr&amp;lt;int&amp;gt; shared_bad(new int[10]); } // the destructor calls delete, undefined behavior as it's an array { std::shared_ptr&amp;lt;int&amp;gt; shared_good(new int[10], std::default_delete&amp;lt;int[]&amp;gt; ()); } // the destructor calls delete[], ok ==================================================================== Example 5: (Valid only C++17 onwards) { shared_ptr&amp;lt;int[]&amp;gt; shared_best(new int[10]); } // the destructor calls delete[], awesome!! ==================================================================== &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;ways-to-specify-custom-deleters&quot;&gt;Ways to specify custom deleters&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;em&gt;std::function&lt;/em&gt; — Heavy size contribution ( ~32 bytes! on x64)&lt;/li&gt; &lt;li&gt;Function pointer — Just a pointer&lt;/li&gt; &lt;li&gt;Stateless functor / Stateless Lambda — None.&lt;/li&gt; &lt;li&gt;Stateful functor / Stateful Lambda — sizeof(functor or lambda)&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;using-custom-deleter-with-shared_ptr&quot;&gt;Using custom deleter with shared_ptr&lt;/h3&gt; &lt;p&gt;Examples —&lt;/p&gt; &lt;h4 id=&quot;1-use-a-proper-functor-&quot;&gt;1. Use a proper functor —&lt;/h4&gt; &lt;p&gt;(Requires custom deleter for array only Prior to C++17)&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// declare the function object template&amp;lt; typename T &amp;gt; struct array_deleter { void operator ()( T const * p) { delete[] p; } }; // and use shared_ptr as follows by constructing function object std::shared_ptr&amp;lt;int&amp;gt; sp(new int[10], array_deleter&amp;lt;int&amp;gt;()); &lt;/code&gt;&lt;/pre&gt; &lt;h4 id=&quot;2-use-a-plain-lambda&quot;&gt;2. Use a plain lambda&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::shared_ptr&amp;lt;MyType&amp;gt; sp(new int[10], [](int *p) { delete[] p; }); &lt;/code&gt;&lt;/pre&gt; &lt;h4 id=&quot;3-use-default_delete-only-valid-for-array-types-before-c17&quot;&gt;3. Use default_delete (Only valid for array types before C++17)&lt;/h4&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::shared_ptr&amp;lt;int&amp;gt; sp(new int[10], std::default_delete&amp;lt;int[]&amp;gt;()); &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;em&gt;delete ptr&lt;/em&gt; is same as specifying &lt;code&gt;default_delete&amp;lt;T&amp;gt;{}ptr&lt;/code&gt;.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;using-custom-deleter-with-unique_ptr&quot;&gt;Using custom deleter with unique_ptr&lt;/h3&gt; &lt;p&gt;With &lt;em&gt;unique_ptr&lt;/em&gt; there is a bit more complication. The main thing is that a deleter type will be part of &lt;em&gt;unique_ptr&lt;/em&gt; type.&lt;/p&gt; &lt;p&gt;By default we get &lt;em&gt;std::default_delete&lt;/em&gt; so here are some examples —&lt;/p&gt; &lt;p&gt;For a class &lt;strong&gt;&lt;em&gt;MyType&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;class MyType { // ... // ... }; void deleter(MyType*) { // ... } ==================================================================== // 1. std::function std::unique_ptr&amp;lt;MyType, std::function&amp;lt;void (MyType*)&amp;gt;&amp;gt; u1(new MyType()); //OR std::unique_ptr&amp;lt;MyType, decltype(deleter)&amp;gt;&amp;gt; u1(new MyType(), &amp;amp;deleter); // 2nd argument is optional always as functor object is created by default ==================================================================== // 2. Function pointer std::unique_ptr&amp;lt;MyType, void (*)(MyType *)&amp;gt; u2(new MyType()); ==================================================================== // A stateless functor struct MyTypeDeleterFunctor { void operator()(MyType* p) { // ... } }; // 3. Stateless functor std::unique_ptr&amp;lt;MyType, MyTypeDeleterFunctor&amp;gt;u3(new MyType()); ==================================================================== // 4. void close_file(std::FILE* fp) { std::fclose(fp); } &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;storage-of-custom-deleters&quot;&gt;Storage of custom deleters&lt;/h3&gt; &lt;p&gt;&lt;strong&gt;For shared_ptr&lt;/strong&gt; When you use a custom deleter it won’t affect the size of your &lt;em&gt;shared_ptr&lt;/em&gt; type. If you remember, &lt;em&gt;shared_ptr&lt;/em&gt; size should be roughly &lt;em&gt;2 x sizeof(ptr)&lt;/em&gt; so where does this deleter hide?&lt;/p&gt; &lt;p&gt;As we know, shared_ptr consists of two things: pointer to the object and pointer to the control block (that contains ref count). Inside the control block structure of &lt;em&gt;shared_ptr&lt;/em&gt; , there is a space for custom deleter and allocator.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;For unique_ptr&lt;/strong&gt; &lt;em&gt;unique_ptr&lt;/em&gt; is small and efficient; the size is one pointer so where is the custom allocator hide in this case?&lt;/p&gt; &lt;p&gt;The deleter is part of the type of &lt;em&gt;unique_ptr&lt;/em&gt;. And since the functor/lambda that is stateless, its type fully encodes everything there is to know about this without any size involvement. Using function pointer takes one pointer size and std::function takes even more size.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;The &lt;em&gt;shared_ptr&lt;/em&gt; always stores a deleter, this erases the type of the deleter, which might be useful in APIs. The disadvantages of using &lt;em&gt;shared_ptr&lt;/em&gt; over &lt;em&gt;unique_ptr&lt;/em&gt; include a higher memory cost for storing the deleter and a performance cost for maintaining the reference count.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;strong&gt;Trivia:&lt;/strong&gt; The size of &lt;em&gt;weak_ptr&lt;/em&gt; is the same as that of &lt;em&gt;shared_ptr&lt;/em&gt;. Weak pointer points to the same control block as it’s shared pointer. When a &lt;em&gt;weak_ptr&lt;/em&gt; is created, destroyed, or copied a second reference count (weak pointer reference count) is manipulated. Weak count is connected with object storage deallocation (Refer prerequisite &lt;a href=&quot;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&quot;&gt;talk&lt;/a&gt;)&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;restrictions-that-come-with-custom-deleter&quot;&gt;Restrictions that come with custom deleter&lt;/h3&gt; &lt;h4 id=&quot;cant-use-make_shared-with-shared_ptr&quot;&gt;Can’t use &lt;em&gt;make_shared&lt;/em&gt; with &lt;em&gt;shared_ptr&lt;/em&gt;&lt;/h4&gt; &lt;p&gt;Unfortunately, you can pass a custom deleter only in the constructor of &lt;em&gt;shared_ptr&lt;/em&gt; there is no way to use &lt;em&gt;make_shared&lt;/em&gt;. This might be a bit of disadvantage (Refer prerequisite &lt;a href=&quot;https://medium.com/pranayaggarwal25/a-tale-of-two-allocations-f61aa0bf71fc&quot;&gt;talk&lt;/a&gt;)&lt;/p&gt; &lt;p&gt;One can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared&quot;&gt;allocate_shared&lt;/a&gt; and custom allocator and deleter, but that’s too complex to be covered in this article.&lt;/p&gt; &lt;h4 id=&quot;cant-use-make_unique-with-unique_ptr&quot;&gt;Can’t use &lt;em&gt;make_unique&lt;/em&gt; with &lt;em&gt;unique_ptr&lt;/em&gt;&lt;/h4&gt; &lt;p&gt;Similarly as with shared_ptr you can pass a custom deleter only in the constructor of unique_ptr and thus you cannot use make_unique.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;references&quot;&gt;References:&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/4gu77b/code_and_graphics_custom_deleters_for_c_smart/&quot;&gt;https://www.reddit.com/r/cpp/comments/4gu77b/code_and_graphics_custom_deleters_for_c_smart/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.bfilipek.com/2016/04/custom-deleters-for-c-smart-pointers.html&quot;&gt;https://www.bfilipek.com/2016/04/custom-deleters-for-c-smart-pointers.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://en.cppreference.com/w/cpp/memory/default_delete&quot;&gt;https://en.cppreference.com/w/cpp/memory/default_delete&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/51255583/shouldnt-stdshared-ptr-use-stddefault-delete-by-default&quot;&gt;https://stackoverflow.com/questions/51255583/shouldnt-stdshared-ptr-use-stddefault-delete-by-default&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.programming-books.io/essential/cpp/using-custom-deleters-to-create-a-wrapper-to-a-c-interface-e8fe82bfeff74f699dc810b6cd5ce57a&quot;&gt;https://www.programming-books.io/essential/cpp/using-custom-deleters-to-create-a-wrapper-to-a-c-interface-e8fe82bfeff74f699dc810b6cd5ce57a&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;p&gt;Thanks for reading this article! Feel free to leave your comments and let me know what you think. Please feel free to drop any comments to improve this article.&lt;/p&gt; &lt;p&gt;Please check out our &lt;a href=&quot;https://techmunching.com&quot;&gt;other articles&lt;/a&gt; and &lt;a href=&quot;https://techmunching.com&quot;&gt;website&lt;/a&gt;, Have a great day!&lt;/p&gt;</content><author><name>admin</name></author><category term="C++"/><summary type="html">How to use a custom deleter with an unique_ptr and shared_ptr</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://techmunching.com/img/0*doMK1rnrcwhJmTks"/><media:content medium="image" url="https://techmunching.com/img/0*doMK1rnrcwhJmTks" xmlns:media="http://search.yahoo.com/mrss/"/></entry><entry><title type="html">Universal Reference and Perfect forwarding</title><link href="https://techmunching.com/universal-reference-and-perfect-forwarding/" rel="alternate" type="text/html" title="Universal Reference and Perfect forwarding"/><published>2020-04-11T00:00:00+00:00</published><updated>2020-04-11T00:00:00+00:00</updated><id>https://techmunching.com/universal-reference-and-perfect-forwarding</id><content type="html" xml:base="https://techmunching.com/universal-reference-and-perfect-forwarding/">&lt;p&gt;&lt;strong&gt;Also known as Forwarding reference&lt;/strong&gt;&lt;/p&gt; &lt;!-- ![](/img/0*wi8CKG57G8q3-woE.gif) --&gt; &lt;div class=&quot;vidWrapper&quot;&gt; &lt;video style=&quot;max-width:100%&quot; autoplay=&quot;&quot; muted=&quot;&quot; loop=&quot;&quot;&gt; &lt;source src=&quot;/img/0*wi8CKG57G8q3-woE.mp4&quot; type=&quot;video/mp4&quot; /&gt; Your browser does not support the video tag. &lt;/video&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;&lt;strong&gt;Prerequisites:&lt;/strong&gt; &lt;a href=&quot;https://medium.com/pranayaggarwal25/rvalue-references-e99dfd3933ff&quot;&gt;Rvalue references&lt;/a&gt;&lt;/p&gt; &lt;h4 id=&quot;table-of-contents&quot;&gt;Table of Contents:&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;Introduction&lt;/li&gt; &lt;li&gt;The double life of “&amp;amp;&amp;amp;”&lt;/li&gt; &lt;li&gt;How to identify a Universal Reference&lt;/li&gt; &lt;li&gt;Universal Reference in templates&lt;/li&gt; &lt;li&gt;Universal Reference in auto&lt;/li&gt; &lt;li&gt;How does the magic of Univeral Reference work?&lt;/li&gt; &lt;li&gt;Handle with care&lt;/li&gt; &lt;li&gt;What is the need? The perfect forwarding problem&lt;/li&gt; &lt;li&gt;How to work with Universal References?&lt;/li&gt; &lt;li&gt;Universal Reference in “typedef”&lt;/li&gt; &lt;li&gt;Universal Reference in “decltype”&lt;/li&gt; &lt;li&gt;The ultimate Truth&lt;/li&gt; &lt;/ol&gt; &lt;hr /&gt; &lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;Every rvalue ref is denoted by &lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt; but vice versa is not true.&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;Rvalue reference ⇒ “&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;” &lt;br /&gt; “&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;” &lt;strong&gt;⇏&lt;/strong&gt; Rvalue reference.&lt;/p&gt; &lt;p&gt;“&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;” in source code though may have the syntactic &lt;em&gt;appearance&lt;/em&gt; of an rvalue reference (“&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;”), but the meaning of an lvalue reference (“&amp;amp;”).&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;the-double-life-of-&quot;&gt;The double Life of “&amp;amp;&amp;amp;”&lt;/h3&gt; &lt;p&gt;There is a double life that “&amp;amp;&amp;amp;” lives on and we need to understand that. Let’s see some examples —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_BejVgArr4hHBus4hS3aoSw.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;The double life of “&amp;amp;&amp;amp;”&lt;/em&gt;&lt;/p&gt; &lt;p&gt;In “&lt;em&gt;type &amp;amp;&amp;amp;&lt;/em&gt;”, &lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt; means either -&lt;/p&gt; &lt;p&gt;&lt;strong&gt;1. Rvalue reference —&lt;/strong&gt; As you’d expect. i) Binds rvalues only&lt;br /&gt; ii) Facilitates the moving of objects.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;2. Forwarding reference&lt;/strong&gt; (a.k.a &lt;strong&gt;Universal reference&lt;/strong&gt;) — The mentioned type is a special type of reference that can bind anything &amp;amp; everything.&lt;/p&gt; &lt;p&gt;i) Universal reference can mean both Rvalue reference and Lvalue reference.&lt;br /&gt; ii) May facilitate copying, may facilitate moving.&lt;br /&gt; iii) Syntactically “type&amp;amp;&amp;amp;” but semantically “type&amp;amp;&amp;amp;” or “type&amp;amp;”.&lt;/p&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;Universal reference can bind lvalues, rvalues (be it const or non-const) thus everything.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h3 id=&quot;how-to-identify-a-universal-reference&quot;&gt;How to identify a Universal Reference&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;&lt;em&gt;If &lt;strong&gt;T&lt;/strong&gt; is getting deduced and variable / parameter type is unqualified &lt;strong&gt;T&amp;amp;&amp;amp;&lt;/strong&gt;, then only it’s a Universal Reference. Here if &lt;strong&gt;T&lt;/strong&gt; has already been deduced, that means no Universal Reference, plain simple rvalue reference.&lt;/em&gt; &lt;em&gt;Not all &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; are Universal Reference.&lt;/em&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;There are 4 possible contexts —&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Function template parameters —&lt;/li&gt; &lt;/ol&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; template&amp;lt;typename MyType&amp;gt; void f(MyType&amp;amp;&amp;amp; param); // &amp;amp;&amp;amp; ≡ rvalue reference &lt;/code&gt;&lt;/pre&gt; &lt;ol&gt; &lt;li&gt;&lt;strong&gt;auto&lt;/strong&gt; declarations &lt;em&gt;auto&amp;amp;&amp;amp; var2 = var1;&lt;/em&gt;&lt;/li&gt; &lt;li&gt;typedef declarations&lt;/li&gt; &lt;li&gt;decltype expressions&lt;/li&gt; &lt;/ol&gt; &lt;p&gt;Out of the above 4, the first two are the most commonly occurring cases. As we have seen in the rule, type deduction is must so —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_hxu81px55zDERu49GRh3bA.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Understanding Type Deduction&lt;/em&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;univeral-references-in-templates&quot;&gt;Univeral references in Templates&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;typename T&amp;gt; void f(T&amp;amp;&amp;amp; param) { std::cout&amp;lt;&amp;lt; __PRETTY_FUNCTION__ &amp;lt;&amp;lt; std::endl; } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;So calling function ‘f’ in different ways will produce different results.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; Calling function ‘f’&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; Widget w; f(w); // T&amp;amp;&amp;amp; forwarding reference will be resolved as Lvalue Ref // Thus instantiating void f(Widget&amp;amp;) out of the template void f(T&amp;amp;&amp;amp;) [with T = Widget&amp;amp;]. // Printed &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt; adding const also —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; const Widget cw; f(cw); // T&amp;amp;&amp;amp; forwarding reference will be resolved as Lvalue Ref to const // Thus instantiating void f(const Widget&amp;amp;) out of the template void f(T&amp;amp;&amp;amp;) [with T = const Widget&amp;amp;]. // Printed &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt; passing rvalues —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; f(Widget()); // T&amp;amp;&amp;amp; forwarding reference will be resolved as Rvalue Ref // Thus instantiating void f(Widget&amp;amp;&amp;amp;) out of the template void f(T&amp;amp;&amp;amp;)[with T = Widget] // Printed, Why?? explained later in Table 2 &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;strong&gt;Example 4:&lt;/strong&gt; adding const with rvalues&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; const Widget cw; f(std::move(cw)); // T&amp;amp;&amp;amp; forwarding reference will be resolved as Rvalue Ref to const // Thus instantiating void f(const Widget&amp;amp;&amp;amp;) out of the template void f(T&amp;amp;&amp;amp;)[with T = const Widget] // Printed, Why? Explained later in Table 2 &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;univeral-references-in-auto&quot;&gt;Univeral references in auto&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;*auto&amp;amp;&amp;amp; var = 10; // 10 is value hence var being // a Universal reference resolves to an rvalue reference. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Type of var is &lt;em&gt;int &amp;amp;&amp;amp;&lt;/em&gt;&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;std::vector&amp;lt;int&amp;gt; vec; auto&amp;amp;&amp;amp; var = vec[0]; // vector[] is int&amp;amp; hence var being // a Universal reference resolves to an Lvalue reference. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Type of var is &lt;em&gt;int&amp;amp;&lt;/em&gt;.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int i = 10; const auto&amp;amp;&amp;amp; var = i; // Not a Universal Reference hence Error!! &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;how-does-the-magic-of-univeral-reference-work&quot;&gt;How does the magic of Univeral Reference work?&lt;/h3&gt; &lt;p&gt;In pre-11 C++, it was not allowed to take a reference to a reference: something like A&amp;amp; &amp;amp; would cause a compile error. C++11, by contrast, introduces the following &lt;strong&gt;R&lt;em&gt;eference collapsing rules&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_kMsWQ7At7DM5eNqZt9QcQg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Table 1: Reference Collapsing Rules&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Reference collapsing is magic that enables Universal references to work. These rules are basically a logical AND of Lvalue ref implying ‘0’ (zero) with Rvalue ref implying ‘1’(one)&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;&lt;em&gt;Reference Collapsing Rule#1: Lvalues are infectious.&lt;/em&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;So basically in the above template examples of Univeral reference —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_QNPrhEdAboP8AubgIxuhdg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Table 2: Reference Collapsing Rules for template Examples 1- 4&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Columns with color code orange here don’t have &amp;amp;&amp;amp; for T. The reason behind that is —&lt;/p&gt; &lt;p&gt;&lt;em&gt;“In template / auto type deduction, references become non-references before lvalue / rvalue analysis. Once deduction takes place, analysis occurs and if lvalue, reference is put back on”&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Also, looking at the table values leads to another rule which is —&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;&lt;em&gt;Reference Collapsing Rule#2: const volatile qualifiers of original type are reserved.&lt;/em&gt;&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;strong&gt;Remember, It’s still impossible to declare a reference to reference explicitly. The compiler can do it, you can’t!!&lt;/strong&gt;&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;handle-with-care&quot;&gt;Handle with care…&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;The thing with overloading used with universal reference is that it almost always turns out differently than expected.&lt;/li&gt; &lt;/ul&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;========================================================= class MyWidget { ...template&amp;lt;typename T&amp;gt; // **Version 1 ** void f(const T&amp;amp; rhs); // Best match for const Lvalue Reftemplate&amp;lt;typename T&amp;gt; // **Version 2 ** void f(T&amp;amp;&amp;amp; rhs); //** universal reference, can handle everything** ... }; ========================================================= MyWidget m; const MyWidget cm; f(m); // Case 1, Calls Version 2!! f(std::move(m)); // Case 2, Calls Version 2 f(cm); // Case 3 Calls Version 1 f(std::move(m)); // Case 4, Calls Version 2 ========================================================= &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This happens as Version 2 of ‘f’ with Universal reference can resolve to anything if needed and thus is a better match for Lvalue Reference. However, if an exact match is found like in case 3, there Version 1 of ‘f’ is called.&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;Another precaution with Universal Reference is that you can’t forward NULL as null pointers because that will be treated as int 0 = (zero). Another reason to use std::nullptr !!&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If braced initializers are passed, the compiler can not deduce the type so you should explicitly mention the type.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;h3 id=&quot;what-is-the-need-the-perfect-forwarding-problem&quot;&gt;What is the need? The perfect forwarding problem&lt;/h3&gt; &lt;p&gt;Let &lt;em&gt;func(E1 E2, … En);&lt;/em&gt; be an arbitrary function call with generic parameters E1, E2, …, En. We’d like to write a function wrapper such that &lt;em&gt;wrapper(E1 E2, … En)&lt;/em&gt; is equivalent to &lt;em&gt;func(E1 E2, … En)&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;The first approach that comes to mind is —&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T1, typename T2&amp;gt; void wrapper(T1 e1, T2 e2) { func(e1, e2); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;But this will not work if ‘func’ accepts its param by reference since ‘wrapper’ is passing its local copies. We can add another definition.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T1, typename T2&amp;gt; void wrapper(T1&amp;amp; e1, T2&amp;amp; e2) { func(e1, e2); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;but what if we would want to pass rvalues also? What about const-ness?&lt;br /&gt; As you see this will be an exponential problem. Brute force solution —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_cnR_CDZLMixWJChrha8nLg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;These are just lvalue versions, rvalue versions will also be needed&lt;/em&gt;&lt;/p&gt; &lt;p&gt;Hence there was a need for perfectly forwarding whatever parameter is received and that is achievable by Universal references.&lt;/p&gt; &lt;hr /&gt; &lt;h3 id=&quot;how-to-work-with-universal-references&quot;&gt;How to work with Universal References?&lt;/h3&gt; &lt;blockquote&gt; &lt;p&gt;A type in independent of lvalueness and rvalueness&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;There are lvalues of type int (e.g., variables declared to be ints), and there are rvalues of type int (e.g., literals like 10)&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; Widget&amp;amp;&amp;amp; var1 = makeWidget() // var1 is an lvalue, but // its type is rvalue reference (to Widget) &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;As with Rvalue references, we use &lt;em&gt;std::move&lt;/em&gt;, with Universal references we should always use &lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/forward&quot;&gt;&lt;code&gt;std::forward&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; present in &lt;utility&gt; header which takes care of copy in case of Lvalue Ref and move in case of Rvalue Ref.&lt;/utility&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;std::forward&lt;/code&gt; keeps the reference type of x. So:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;If &lt;code&gt;x&lt;/code&gt; is an rvalue reference then &lt;code&gt;std::forward&lt;/code&gt; is = &lt;code&gt;std::move&lt;/code&gt;,&lt;/li&gt; &lt;li&gt;If &lt;code&gt;x&lt;/code&gt; is an lvalue reference then &lt;code&gt;std::forward&lt;/code&gt; doesn’t do anything. So for the previous example of &lt;code&gt;wrapper&lt;/code&gt; function on &lt;em&gt;func(E1 E2, … En)&lt;/em&gt; -&lt;/li&gt; &lt;/ul&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt; template &amp;lt;typename T1, typename T2&amp;gt; void wrapper(T1&amp;amp;&amp;amp; e1, T2&amp;amp;&amp;amp; e2) { func(std::forward&amp;lt;T1&amp;gt;(e1), std::forward&amp;lt;T2&amp;gt;(e2)); } // Awesome!! &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;blockquote&gt; &lt;p&gt;std::forward is a conditional cast but std::move is an unconditional cast.Applications of perfect forwarding are &lt;code&gt;std::make_shared&lt;/code&gt; , &lt;code&gt;std::make_unique&lt;/code&gt; , &lt;code&gt;vector::emplace_back&lt;/code&gt; etc.&lt;/p&gt; &lt;/blockquote&gt; &lt;hr /&gt; &lt;h3 id=&quot;universal-references-in-typedef&quot;&gt;Universal references in “typedef”&lt;/h3&gt; &lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;template&amp;lt;typename T&amp;gt; class Widget { // ... } ========================================================= Widget&amp;lt;int&amp;amp;&amp;gt; w; typedef Widget&amp;amp;&amp;amp; UniRefToWodget; UniRefToWodget &amp;amp;v1 = w; // Reference collapsing, v1's type is Widget&amp;amp; const UniRefToWodget &amp;amp;v2 = std::move(w); // Reference collapsing, v2's type is const Widget&amp;amp; UniRefToWodget &amp;amp;&amp;amp;v3 = std::move(w); // Reference collapsing, v3's type is Widget&amp;amp;&amp;amp; &lt;/code&gt;&lt;/pre&gt; &lt;hr /&gt; &lt;h3 id=&quot;universal-references-in-decltype&quot;&gt;Universal References in “decltype”&lt;/h3&gt; &lt;p&gt;For &lt;em&gt;decltype,&lt;/em&gt; Type deduction rule is different.&lt;/p&gt; &lt;ol&gt; &lt;li&gt;decltype(id) ⇒ id’s declared type.&lt;/li&gt; &lt;li&gt;decltype(non-id lvalue expression) ⇒ Expression’s type, &lt;strong&gt;Lvalue Ref (T&amp;amp;)&lt;/strong&gt;&lt;/li&gt; &lt;li&gt;decltype(non-id rvalue expression) ⇒ Expression’s type, &lt;strong&gt;Non-Ref (T)&lt;/strong&gt; &lt;img src=&quot;/img/1_wBdb9YCnAO0VPvwqLWnbJA.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;decltype and Universal Reference&lt;/em&gt;&lt;/li&gt; &lt;/ol&gt; &lt;h3 id=&quot;ultimate-truth&quot;&gt;Ultimate Truth&lt;/h3&gt; &lt;p&gt;“&lt;em&gt;&amp;amp;&amp;amp;&lt;/em&gt;” is really Always Rvalue Reference, but due to the magic of Reference collapsing, It can work as a reference that can work with anything hence the fancy name “Universal Reference” a.k.a. “Forwarding Reference”. :)&lt;/p&gt; &lt;h3 id=&quot;bonus-point--coz-you-made-it-till-here&quot;&gt;Bonus point : coz you made it till here!!&lt;/h3&gt; &lt;p&gt;What does &lt;code&gt;std::forward&lt;/code&gt; do actually?&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_hLPj-EPcjNl2afshgBLaWw.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Implementation of std::forward&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 1:&lt;/strong&gt; passing lvalues sayint&amp;amp; , T is deduced as int&amp;amp;&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_p3CTuZ7DnDKASZlChPn3rg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;Putting T as int&amp;amp;&lt;/em&gt;&lt;/p&gt; &lt;p&gt;After Reference collapsing, &lt;em&gt;std::forward&lt;/em&gt; turns into this, which is as good as passing lvalue.&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_eMkkMxSVP01Aq-uzj1okmw.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;The final definition looks like this after Reference collapsing&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Case 2:&lt;/strong&gt; passing rvalues say &lt;em&gt;int&amp;amp;&amp;amp;&lt;/em&gt; , T is deduced as int (Why? Read note mentioned after Table 2).&lt;/p&gt; &lt;p&gt;Now After applying T as int —&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;/img/1_rqib7b-jjZtkHYHDf3neZg.webp&quot; alt=&quot;&quot; /&gt;&lt;em&gt;The final definition looks like this after Reference collapsing&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;std::forward&lt;/em&gt; could do the job without &lt;a href=&quot;https://en.cppreference.com/w/cpp/types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;. Reference collapsing does the job already, so &lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;&lt;/code&gt; is superfluous.&lt;/p&gt; &lt;p&gt;But it’s there to turn the T&amp;amp;t into a non-deducing context, thus forcing us to explicitly specify the template parameter when calling &lt;em&gt;std::forward&lt;/em&gt; .&lt;/p&gt; &lt;h3 id=&quot;references&quot;&gt;References&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers#NittyGrittyDetails&quot;&gt;https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers#NittyGrittyDetails&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11&quot;&gt;https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://thbecker.net/articles/rvalue_references/section_08.html&quot;&gt;http://thbecker.net/articles/rvalue_references/section_08.html&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.fluentcpp.com/2018/02/06/understanding-lvalues-rvalues-and-their-references/&quot;&gt;https://www.fluentcpp.com/2018/02/06/understanding-lvalues-rvalues-and-their-references/&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c&quot;&gt;https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/oliora/hot-universal-references-and-perfect-forwarding-82155460&quot;&gt;https://www.slideshare.net/oliora/hot-universal-references-and-perfect-forwarding-82155460&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://thbecker.net/articles/rvalue_references/section_01.html&quot;&gt;http://thbecker.net/articles/rvalue_references/section_01.html&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt;</content><author><name>admin</name></author><category term="C++"/><summary type="html">Also known as Forwarding reference</summary></entry></feed>